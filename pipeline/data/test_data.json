{
    "repository/filecoin-solidity/lib/solidity-bignumber/src/BigNumbers.sol": [
        {
            "methods": [
                {
                    "identifier": "verify",
                    "parameters": "BigNumber memory bn",
                    "modifiers": "pure",
                    "return": "",
                    "body": "function verify(\n        BigNumber memory bn\n    ) internal pure {\n        uint msword; \n        bytes memory val = bn.val;\n        assembly {msword := mload(add(val,0x20))} //get msword of result\n        if(msword==0) require(isZero(bn));\n        else require((bn.val.length % 32 == 0) && (msword>>((bn.bitlen%256)-1)==1));\n    }",
                    "start": "31",
                    "end": "39",
                    "class": "BigNumbers",
                    "signature": " verifyBigNumber memory bn",
                    "full_signature": "function verify(BigNumber memory bn) internal pure",
                    "class_method_signature": "BigNumbers.verifyBigNumber memory bn",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Verifies the validity of a BigNumber.\n *\n * Steps:\n * 1. Declares a variable to store the most significant word (msword).\n * 2. Gets the value bytes from the BigNumber.\n * 3. Uses assembly to load the msword from the value bytes.\n *\n * 4. If the msword is zero:\n *    - Requires that the BigNumber is actually zero.\n * 5. Else:\n *    - Requires that:\n *      a) The value length is a multiple of 32 bytes\n *      b) The most significant bit (based on bitlen) is set to 1\n */",
                    "tdd": "{'function verify(\\n        BigNumber memory bn\\n    ) internal pure {\\n        uint msword; \\n        bytes memory val = bn.val;\\n        assembly {msword := mload(add(val,0x20))} //get msword of result\\n        if(msword==0) require(isZero(bn));\\n        else require((bn.val.length % 32 == 0) && (msword>>((bn.bitlen%256)-1)==1));\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "init",
                    "parameters": "bytes memory val, bool neg, uint bitlen",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function init(\n        bytes memory val, \n        bool neg, \n        uint bitlen\n    ) internal view returns(BigNumber memory){\n        return _init(val, neg, bitlen);\n    }",
                    "start": "51",
                    "end": "57",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) initbytes memory val, bool neg, uint bitlen",
                    "full_signature": "function init(bytes memory val, bool neg, uint bitlen) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.initbytes memory val, bool neg, uint bitlen",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Initializes a BigNumber struct with the given parameters.\n *\n * @param val The byte array representing the value of the BigNumber.\n * @param neg Boolean flag indicating if the BigNumber is negative.\n * @param bitlen The bit length of the BigNumber.\n *\n * @return A BigNumber struct initialized with the provided parameters.\n */",
                    "tdd": "{'function init(\\n        bytes memory val, \\n        bool neg, \\n        uint bitlen\\n    ) internal view returns(BigNumber memory){\\n        return _init(val, neg, bitlen);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "init",
                    "parameters": "bytes memory val, bool neg",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function init(\n        bytes memory val, \n        bool neg\n    ) internal view returns(BigNumber memory){\n        return _init(val, neg, 0);\n    }",
                    "start": "66",
                    "end": "71",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) initbytes memory val, bool neg",
                    "full_signature": "function init(bytes memory val, bool neg) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.initbytes memory val, bool neg",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Initializes a BigNumber struct with given value and sign.\n * @dev Internal function that wraps _init with default precision of 0.\n * @param val The byte array representing the numeric value.\n * @param neg Boolean flag indicating if the number is negative.\n * @return BigNumber Returns the initialized BigNumber struct.\n */",
                    "tdd": "{'function init(\\n        bytes memory val, \\n        bool neg\\n    ) internal view returns(BigNumber memory){\\n        return _init(val, neg, 0);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "init",
                    "parameters": "uint val, bool neg",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function init(\n        uint val, \n        bool neg\n    ) internal view returns(BigNumber memory){\n        return _init(abi.encodePacked(val), neg, 0);\n    }",
                    "start": "81",
                    "end": "86",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) inituint val, bool neg",
                    "full_signature": "function init(uint val, bool neg) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.inituint val, bool neg",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Initializes a BigNumber struct with the given value and sign.\n *\n * @param val The unsigned integer value to initialize the BigNumber with.\n * @param neg Boolean flag indicating if the BigNumber should be negative (true) or positive (false).\n *\n * @return A BigNumber memory struct initialized with the provided value and sign.\n *\n * @dev Internally calls _init() with the encoded value, sign flag, and a precision of 0.\n */",
                    "tdd": "{'function init(\\n        uint val, \\n        bool neg\\n    ) internal view returns(BigNumber memory){\\n        return _init(abi.encodePacked(val), neg, 0);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "add",
                    "parameters": "BigNumber memory a, BigNumber memory b",
                    "modifiers": "pure",
                    "return": "returns(BigNumber memory r)",
                    "body": "function add(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(BigNumber memory r) {\n        if(a.bitlen==0 && b.bitlen==0) return zero();\n        if(a.bitlen==0) return b;\n        if(b.bitlen==0) return a;\n        bytes memory val;\n        uint bitlen;\n        int compare = cmp(a,b,false);\n\n        if(a.neg || b.neg){\n            if(a.neg && b.neg){\n                if(compare>=0) (val, bitlen) = _add(a.val,b.val,a.bitlen);\n                else (val, bitlen) = _add(b.val,a.val,b.bitlen);\n                r.neg = true;\n            }\n            else {\n                if(compare==1){\n                    (val, bitlen) = _sub(a.val,b.val);\n                    r.neg = a.neg;\n                }\n                else if(compare==-1){\n                    (val, bitlen) = _sub(b.val,a.val);\n                    r.neg = !a.neg;\n                }\n                else return zero();//one pos and one neg, and same value.\n            }\n        }\n        else{\n            if(compare>=0){ // a>=b\n                (val, bitlen) = _add(a.val,b.val,a.bitlen);\n            }\n            else {\n                (val, bitlen) = _add(b.val,a.val,b.bitlen);\n            }\n            r.neg = false;\n        }\n\n        r.val = val;\n        r.bitlen = (bitlen);\n    }",
                    "start": "103",
                    "end": "144",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory r) addBigNumber memory a, BigNumber memory b",
                    "full_signature": "function add(BigNumber memory a, BigNumber memory b) internal pure returns(BigNumber memory r)",
                    "class_method_signature": "BigNumbers.addBigNumber memory a, BigNumber memory b",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds two BigNumber values and returns the result.\n * @dev Handles both positive and negative numbers, with proper sign determination.\n *\n * Steps:\n * 1. Check if either input is zero and return the other number if true.\n * 2. Compare the absolute values of the two numbers.\n * 3. Handle different cases based on the signs of the inputs:\n *    a) If both numbers are negative:\n *       - Add their absolute values\n *       - Set result as negative\n *    b) If numbers have opposite signs:\n *       - Subtract smaller absolute value from larger\n *       - Determine result sign based on inputs\n *       - Return zero if values are equal but signs opposite\n *    c) If both numbers are positive:\n *       - Simply add their values\n * 4. Store the resulting value and bit length in the return struct.\n *\n * @param a The first BigNumber operand\n * @param b The second BigNumber operand\n * @return r The resulting BigNumber after addition\n */",
                    "tdd": "{'function add(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(BigNumber memory r) {\\n        if(a.bitlen==0 && b.bitlen==0) return zero();\\n        if(a.bitlen==0) return b;\\n        if(b.bitlen==0) return a;\\n        bytes memory val;\\n        uint bitlen;\\n        int compare = cmp(a,b,false);\\n\\n        if(a.neg || b.neg){\\n            if(a.neg && b.neg){\\n                if(compare>=0) (val, bitlen) = _add(a.val,b.val,a.bitlen);\\n                else (val, bitlen) = _add(b.val,a.val,b.bitlen);\\n                r.neg = true;\\n            }\\n            else {\\n                if(compare==1){\\n                    (val, bitlen) = _sub(a.val,b.val);\\n                    r.neg = a.neg;\\n                }\\n                else if(compare==-1){\\n                    (val, bitlen) = _sub(b.val,a.val);\\n                    r.neg = !a.neg;\\n                }\\n                else return zero();//one pos and one neg, and same value.\\n            }\\n        }\\n        else{\\n            if(compare>=0){ // a>=b\\n                (val, bitlen) = _add(a.val,b.val,a.bitlen);\\n            }\\n            else {\\n                (val, bitlen) = _add(b.val,a.val,b.bitlen);\\n            }\\n            r.neg = false;\\n        }\\n\\n        r.val = val;\\n        r.bitlen = (bitlen);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "mul",
                    "parameters": "BigNumber memory a, BigNumber memory b",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory r)",
                    "body": "function mul(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal view returns(BigNumber memory r){\n            \n        BigNumber memory lhs = add(a,b);\n        BigNumber memory fst = modexp(lhs, two(), _powModulus(lhs, 2)); // (a+b)^2\n        \n        // no need to do subtraction part of the equation if a == b; if so, it has no effect on final result.\n        if(!eq(a,b)) {\n            BigNumber memory rhs = sub(a,b);\n            BigNumber memory snd = modexp(rhs, two(), _powModulus(rhs, 2)); // (a-b)^2\n            r = _shr(sub(fst, snd) , 2); // (a * b) = (((a + b)**2 - (a - b)**2) / 4\n        }\n        else {\n            r = _shr(fst, 2); // a==b ? (((a + b)**2 / 4\n        }\n    }",
                    "start": "210",
                    "end": "227",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory r) mulBigNumber memory a, BigNumber memory b",
                    "full_signature": "function mul(BigNumber memory a, BigNumber memory b) internal view returns(BigNumber memory r)",
                    "class_method_signature": "BigNumbers.mulBigNumber memory a, BigNumber memory b",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Multiplies two BigNumber values using a mathematical identity.\n *\n * The function uses the identity: (a * b) = ((a + b)^2 - (a - b)^2) / 4\n * \n * Steps:\n * 1. Calculate (a + b) and store in lhs.\n * 2. Compute (a + b)^2 using modexp and store in fst.\n *\n * 3. If a and b are not equal:\n *    - Calculate (a - b) and store in rhs.\n *    - Compute (a - b)^2 using modexp and store in snd.\n *    - Compute the final result as ((fst - snd) / 4) using _shr.\n *\n * 4. If a and b are equal:\n *    - Compute the final result as (fst / 4) using _shr.\n *\n * @param a First BigNumber operand.\n * @param b Second BigNumber operand.\n * @return r Result of the multiplication as a BigNumber.\n */",
                    "tdd": "{'function mul(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal view returns(BigNumber memory r){\\n            \\n        BigNumber memory lhs = add(a,b);\\n        BigNumber memory fst = modexp(lhs, two(), _powModulus(lhs, 2)); // (a+b)^2\\n        \\n        // no need to do subtraction part of the equation if a == b; if so, it has no effect on final result.\\n        if(!eq(a,b)) {\\n            BigNumber memory rhs = sub(a,b);\\n            BigNumber memory snd = modexp(rhs, two(), _powModulus(rhs, 2)); // (a-b)^2\\n            r = _shr(sub(fst, snd) , 2); // (a * b) = (((a + b)**2 - (a - b)**2) / 4\\n        }\\n        else {\\n            r = _shr(fst, 2); // a==b ? (((a + b)**2 / 4\\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "divVerify",
                    "parameters": "BigNumber memory a, BigNumber memory b, BigNumber memory r",
                    "modifiers": "view",
                    "return": "returns(bool)",
                    "body": "function divVerify(\n        BigNumber memory a, \n        BigNumber memory b, \n        BigNumber memory r\n    ) internal view returns(bool) {\n\n        // first do zero check.\n        // if a<b (always zero) and r==zero (input check), return true.\n        if(cmp(a, b, false) == -1){\n            require(cmp(zero(), r, false)==0);\n            return true;\n        }\n\n        // Following zero check:\n        //if both negative: result positive\n        //if one negative: result negative\n        //if neither negative: result positive\n        bool positiveResult = ( a.neg && b.neg ) || (!a.neg && !b.neg);\n        require(positiveResult ? !r.neg : r.neg);\n        \n        // require denominator to not be zero.\n        require(!(cmp(b,zero(),true)==0));\n        \n        // division result check assumes inputs are positive.\n        // we have already checked for result sign so this is safe.\n        bool[3] memory negs = [a.neg, b.neg, r.neg];\n        a.neg = false;\n        b.neg = false;\n        r.neg = false;\n\n        // do multiplication (b * r)\n        BigNumber memory fst = mul(b,r);\n        // check if we already have 'a' (ie. no remainder after division). if so, no mod necessary, and return true.\n        if(cmp(fst,a,true)==0) return true;\n        //a mod (b*r)\n        BigNumber memory snd = modexp(a,one(),fst); \n        // ((b*r) + a % (b*r)) == a\n        require(cmp(add(fst,snd),a,true)==0); \n\n        a.neg = negs[0];\n        b.neg = negs[1];\n        r.neg = negs[2];\n\n        return true;\n    }",
                    "start": "246",
                    "end": "290",
                    "class": "BigNumbers",
                    "signature": "returns(bool) divVerifyBigNumber memory a, BigNumber memory b, BigNumber memory r",
                    "full_signature": "function divVerify(BigNumber memory a, BigNumber memory b, BigNumber memory r) internal view returns(bool)",
                    "class_method_signature": "BigNumbers.divVerifyBigNumber memory a, BigNumber memory b, BigNumber memory r",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Verifies the correctness of division operation between BigNumber values.\n *\n * Steps:\n * 1. First performs zero check:\n *    - If a < b (always zero result) and r == zero (input check), returns true.\n *\n * 2. Checks result sign correctness:\n *    - If both operands are negative or both positive, result should be positive.\n *    - If one operand is negative, result should be negative.\n *\n * 3. Ensures denominator (b) is not zero.\n *\n * 4. Temporarily removes sign information for calculation:\n *    - Stores original signs of a, b, and r.\n *    - Sets all signs to false (positive) for calculation.\n *\n * 5. Performs multiplication check:\n *    - Multiplies b and r (fst = b * r).\n *    - If fst equals a (no remainder), returns true.\n *\n * 6. Performs modulo check:\n *    - Calculates a mod (b*r) (snd = a % (b*r)).\n *    - Verifies that (b*r) + (a % (b*r)) equals a.\n *\n * 7. Restores original sign information to the numbers.\n *\n * 8. Returns true if all checks pass.\n *\n * Note: This function assumes BigNumber struct contains 'neg' flag for sign and uses helper functions:\n * - cmp() for comparison\n * - mul() for multiplication\n * - modexp() for modulo\n * - add() for addition\n * - zero() and one() for constants\n */",
                    "tdd": "{\"function divVerify(\\n        BigNumber memory a, \\n        BigNumber memory b, \\n        BigNumber memory r\\n    ) internal view returns(bool) {\\n\\n        // first do zero check.\\n        // if a<b (always zero) and r==zero (input check), return true.\\n        if(cmp(a, b, false) == -1){\\n            require(cmp(zero(), r, false)==0);\\n            return true;\\n        }\\n\\n        // Following zero check:\\n        //if both negative: result positive\\n        //if one negative: result negative\\n        //if neither negative: result positive\\n        bool positiveResult = ( a.neg && b.neg ) || (!a.neg && !b.neg);\\n        require(positiveResult ? !r.neg : r.neg);\\n        \\n        // require denominator to not be zero.\\n        require(!(cmp(b,zero(),true)==0));\\n        \\n        // division result check assumes inputs are positive.\\n        // we have already checked for result sign so this is safe.\\n        bool[3] memory negs = [a.neg, b.neg, r.neg];\\n        a.neg = false;\\n        b.neg = false;\\n        r.neg = false;\\n\\n        // do multiplication (b * r)\\n        BigNumber memory fst = mul(b,r);\\n        // check if we already have 'a' (ie. no remainder after division). if so, no mod necessary, and return true.\\n        if(cmp(fst,a,true)==0) return true;\\n        //a mod (b*r)\\n        BigNumber memory snd = modexp(a,one(),fst); \\n        // ((b*r) + a % (b*r)) == a\\n        require(cmp(add(fst,snd),a,true)==0); \\n\\n        a.neg = negs[0];\\n        b.neg = negs[1];\\n        r.neg = negs[2];\\n\\n        return true;\\n    }\"}",
                    "context": "set()"
                },
                {
                    "identifier": "mod",
                    "parameters": "BigNumber memory a, BigNumber memory n",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function mod(\n        BigNumber memory a, \n        BigNumber memory n\n    ) internal view returns(BigNumber memory){\n      return modexp(a,one(),n);\n    }",
                    "start": "315",
                    "end": "320",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) modBigNumber memory a, BigNumber memory n",
                    "full_signature": "function mod(BigNumber memory a, BigNumber memory n) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.modBigNumber memory a, BigNumber memory n",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Computes the modulus of a BigNumber with respect to another BigNumber.\n * @dev Uses the modexp function to calculate a^1 mod n (which is equivalent to a mod n).\n * @param a The BigNumber to be reduced.\n * @param n The modulus BigNumber.\n * @return The result of a mod n as a BigNumber.\n */",
                    "tdd": "{'function mod(\\n        BigNumber memory a, \\n        BigNumber memory n\\n    ) internal view returns(BigNumber memory){\\n      return modexp(a,one(),n);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "modmul",
                    "parameters": "BigNumber memory a, BigNumber memory b, BigNumber memory n",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function modmul(\n        BigNumber memory a, \n        BigNumber memory b, \n        BigNumber memory n) internal view returns(BigNumber memory) {       \n        return mod(mul(a,b), n);       \n    }",
                    "start": "405",
                    "end": "410",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) modmulBigNumber memory a, BigNumber memory b, BigNumber memory n",
                    "full_signature": "function modmul(BigNumber memory a, BigNumber memory b, BigNumber memory n) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.modmulBigNumber memory a, BigNumber memory b, BigNumber memory n",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Performs modular multiplication of two BigNumbers.\n * @dev Multiplies two BigNumbers (a and b) and then applies modulus operation with n.\n * @param a The first BigNumber to multiply.\n * @param b The second BigNumber to multiply.\n * @param n The modulus value.\n * @return The result of (a * b) mod n as a BigNumber.\n */",
                    "tdd": "{'function modmul(\\n        BigNumber memory a, \\n        BigNumber memory b, \\n        BigNumber memory n) internal view returns(BigNumber memory) {       \\n        return mod(mul(a,b), n);       \\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "eq",
                    "parameters": "BigNumber memory a, BigNumber memory b",
                    "modifiers": "pure",
                    "return": "returns(bool)",
                    "body": "function eq(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==0) ? true : false;\n    }",
                    "start": "519",
                    "end": "525",
                    "class": "BigNumbers",
                    "signature": "returns(bool) eqBigNumber memory a, BigNumber memory b",
                    "full_signature": "function eq(BigNumber memory a, BigNumber memory b) internal pure returns(bool)",
                    "class_method_signature": "BigNumbers.eqBigNumber memory a, BigNumber memory b",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Compares two BigNumber values for equality.\n * @param a The first BigNumber to compare.\n * @param b The second BigNumber to compare.\n * @return bool Returns true if the numbers are equal, false otherwise.\n *\n * Steps:\n * 1. Calls the internal cmp function to compare the two BigNumbers.\n * 2. Returns true if the comparison result is 0 (equal), false otherwise.\n */",
                    "tdd": "{'function eq(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==0) ? true : false;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "gt",
                    "parameters": "BigNumber memory a, BigNumber memory b",
                    "modifiers": "pure",
                    "return": "returns(bool)",
                    "body": "function gt(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==1) ? true : false;\n    }",
                    "start": "534",
                    "end": "540",
                    "class": "BigNumbers",
                    "signature": "returns(bool) gtBigNumber memory a, BigNumber memory b",
                    "full_signature": "function gt(BigNumber memory a, BigNumber memory b) internal pure returns(bool)",
                    "class_method_signature": "BigNumbers.gtBigNumber memory a, BigNumber memory b",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Compares two BigNumber values to check if the first is greater than the second.\n * @param a The first BigNumber to compare.\n * @param b The second BigNumber to compare.\n * @return bool Returns true if a is greater than b, false otherwise.\n * \n * Steps:\n * 1. Calls the internal cmp function to compare the two BigNumbers.\n * 2. Returns true if the comparison result is 1, otherwise returns false.\n */",
                    "tdd": "{'function gt(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==1) ? true : false;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "lt",
                    "parameters": "BigNumber memory a, BigNumber memory b",
                    "modifiers": "pure",
                    "return": "returns(bool)",
                    "body": "function lt(\n        BigNumber memory a, \n        BigNumber memory b\n    ) internal pure returns(bool){\n        int result = cmp(a, b, true);\n        return (result==-1) ? true : false;\n    }",
                    "start": "564",
                    "end": "570",
                    "class": "BigNumbers",
                    "signature": "returns(bool) ltBigNumber memory a, BigNumber memory b",
                    "full_signature": "function lt(BigNumber memory a, BigNumber memory b) internal pure returns(bool)",
                    "class_method_signature": "BigNumbers.ltBigNumber memory a, BigNumber memory b",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Compares two BigNumber values and checks if the first is less than the second.\n *\n * @param a The first BigNumber to compare.\n * @param b The second BigNumber to compare.\n *\n * @return bool Returns true if `a` is less than `b`, otherwise false.\n *\n * Steps:\n * 1. Calls the internal `cmp` function to compare `a` and `b`.\n * 2. Returns true if the comparison result is -1 (indicating `a` < `b`).\n * 3. Returns false otherwise.\n */",
                    "tdd": "{'function lt(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==-1) ? true : false;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "shr",
                    "parameters": "BigNumber memory a, uint bits",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function shr(\n        BigNumber memory a, \n        uint bits\n    ) internal view returns(BigNumber memory){\n        require(!a.neg);\n        return _shr(a, bits);\n    }",
                    "start": "594",
                    "end": "600",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) shrBigNumber memory a, uint bits",
                    "full_signature": "function shr(BigNumber memory a, uint bits) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.shrBigNumber memory a, uint bits",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Performs a right shift operation on a positive BigNumber.\n * @dev The function requires that the input BigNumber is not negative.\n * @param a The BigNumber to be shifted.\n * @param bits The number of bits to shift right.\n * @return A new BigNumber representing the shifted value.\n *\n * Steps:\n * 1. Check that the input BigNumber is not negative.\n * 2. Call the internal _shr function to perform the right shift.\n * 3. Return the shifted BigNumber.\n */",
                    "tdd": "{'function shr(\\n        BigNumber memory a, \\n        uint bits\\n    ) internal view returns(BigNumber memory){\\n        require(!a.neg);\\n        return _shr(a, bits);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "shl",
                    "parameters": "BigNumber memory a, uint bits",
                    "modifiers": "view",
                    "return": "returns(BigNumber memory)",
                    "body": "function shl(\n        BigNumber memory a, \n        uint bits\n    ) internal view returns(BigNumber memory){\n        require(!a.neg);\n        return _shl(a, bits);\n    }",
                    "start": "684",
                    "end": "690",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) shlBigNumber memory a, uint bits",
                    "full_signature": "function shl(BigNumber memory a, uint bits) internal view returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.shlBigNumber memory a, uint bits",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Performs a left shift operation on a BigNumber.\n * @dev The input BigNumber must be non-negative (neg flag must be false).\n * @param a The BigNumber to be shifted.\n * @param bits The number of bits to shift left.\n * @return BigNumber The result of the left shift operation.\n */",
                    "tdd": "{'function shl(\\n        BigNumber memory a, \\n        uint bits\\n    ) internal view returns(BigNumber memory){\\n        require(!a.neg);\\n        return _shl(a, bits);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "bitLength",
                    "parameters": "BigNumber memory a",
                    "modifiers": "pure",
                    "return": "returns(uint)",
                    "body": "function bitLength(\n        BigNumber memory a\n    ) internal pure returns(uint){\n        return bitLength(a.val);\n    }",
                    "start": "751",
                    "end": "755",
                    "class": "BigNumbers",
                    "signature": "returns(uint) bitLengthBigNumber memory a",
                    "full_signature": "function bitLength(BigNumber memory a) internal pure returns(uint)",
                    "class_method_signature": "BigNumbers.bitLengthBigNumber memory a",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Returns the bit length of a BigNumber.\n * @dev Internal pure function that calculates the number of bits \n *      required to represent the BigNumber's value.\n * @param a The BigNumber whose bit length is to be calculated.\n * @return The number of bits required to represent the BigNumber's value.\n */",
                    "tdd": "{'function bitLength(\\n        BigNumber memory a\\n    ) internal pure returns(uint){\\n        return bitLength(a.val);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "bitLength",
                    "parameters": "bytes memory a",
                    "modifiers": "pure",
                    "return": "returns(uint r)",
                    "body": "function bitLength(\n        bytes memory a\n    ) internal pure returns(uint r){\n        if(isZero(a)) return 0;\n        uint msword; \n        assembly {\n            msword := mload(add(a,0x20))               // get msword of input\n        }\n        r = bitLength(msword);                         // get bitlen of msword, add to size of remaining words.\n        assembly {                                           \n            r := add(r, mul(sub(mload(a), 0x20) , 8))  // res += (val.length-32)*8;  \n        }\n    }",
                    "start": "763",
                    "end": "775",
                    "class": "BigNumbers",
                    "signature": "returns(uint r) bitLengthbytes memory a",
                    "full_signature": "function bitLength(bytes memory a) internal pure returns(uint r)",
                    "class_method_signature": "BigNumbers.bitLengthbytes memory a",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the bit length of a bytes array.\n * @dev The function first checks if the input array is empty (zero length).\n *      If not empty, it retrieves the most significant word (msword) of the input.\n *      Then calculates the bit length of the msword and adds it to the size of remaining words.\n *      The final result accounts for the full length of the bytes array.\n * @param a The input bytes array to calculate bit length for.\n * @return r The calculated bit length of the input bytes array.\n *\n * Steps:\n * 1. Check if input bytes array is zero length, return 0 if true.\n * 2. Get the most significant word (msword) of the input using assembly.\n * 3. Calculate bit length of the msword.\n * 4. Add the remaining length (in bits) of the bytes array to the result.\n */",
                    "tdd": "{'function bitLength(\\n        bytes memory a\\n    ) internal pure returns(uint r){\\n        if(isZero(a)) return 0;\\n        uint msword; \\n        assembly {\\n            msword := mload(add(a,0x20))               // get msword of input\\n        }\\n        r = bitLength(msword);                         // get bitlen of msword, add to size of remaining words.\\n        assembly {                                           \\n            r := add(r, mul(sub(mload(a), 0x20) , 8))  // res += (val.length-32)*8;  \\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "bitLength",
                    "parameters": "uint a",
                    "modifiers": "pure",
                    "return": "returns (uint r)",
                    "body": "function bitLength(\n        uint a\n    ) internal pure returns (uint r){\n        assembly {\n            switch eq(a, 0)\n            case 1 {\n                r := 0\n            }\n            default {\n                let arg := a\n                a := sub(a,1)\n                a := or(a, div(a, 0x02))\n                a := or(a, div(a, 0x04))\n                a := or(a, div(a, 0x10))\n                a := or(a, div(a, 0x100))\n                a := or(a, div(a, 0x10000))\n                a := or(a, div(a, 0x100000000))\n                a := or(a, div(a, 0x10000000000000000))\n                a := or(a, div(a, 0x100000000000000000000000000000000))\n                a := add(a, 1)\n                let m := mload(0x40)\n                mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n                mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n                mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n                mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n                mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n                mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n                mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n                mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n                mstore(0x40, add(m, 0x100))\n                let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n                let shift := 0x100000000000000000000000000000000000000000000000000000000000000\n                let _a := div(mul(a, magic), shift)\n                r := div(mload(add(m,sub(255,_a))), shift)\n                r := add(r, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n                // where a is a power of two, result needs to be incremented. we use the power of two trick here: if(arg & arg-1 == 0) ++r;\n                if eq(and(arg, sub(arg, 1)), 0) {\n                    r := add(r, 1) \n                }\n            }\n        }\n    }",
                    "start": "783",
                    "end": "824",
                    "class": "BigNumbers",
                    "signature": "returns (uint r) bitLengthuint a",
                    "full_signature": "function bitLength(uint a) internal pure returns (uint r)",
                    "class_method_signature": "BigNumbers.bitLengthuint a",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the bit length of a given unsigned integer using assembly optimizations.\n * \n * @dev This function uses low-level assembly to efficiently compute the number of bits required to represent the input value.\n * \n * Steps:\n * 1. Handle special case when input is 0 (returns 0).\n * 2. For non-zero inputs:\n *    a. Create a copy of the input argument.\n *    b. Perform bitwise operations to spread the highest set bit to all lower bits.\n *    c. Load magic numbers into memory for bit length calculation.\n *    d. Use mathematical tricks to determine the bit length.\n *    e. Handle edge case for values greater than 2^255.\n *    f. Special handling for exact power-of-two values (increment result).\n * \n * @param a The unsigned integer whose bit length is to be calculated.\n * @return r The number of bits required to represent the input value.\n */",
                    "tdd": "{'function bitLength(\\n        uint a\\n    ) internal pure returns (uint r){\\n        assembly {\\n            switch eq(a, 0)\\n            case 1 {\\n                r := 0\\n            }\\n            default {\\n                let arg := a\\n                a := sub(a,1)\\n                a := or(a, div(a, 0x02))\\n                a := or(a, div(a, 0x04))\\n                a := or(a, div(a, 0x10))\\n                a := or(a, div(a, 0x100))\\n                a := or(a, div(a, 0x10000))\\n                a := or(a, div(a, 0x100000000))\\n                a := or(a, div(a, 0x10000000000000000))\\n                a := or(a, div(a, 0x100000000000000000000000000000000))\\n                a := add(a, 1)\\n                let m := mload(0x40)\\n                mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n                mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n                mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n                mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n                mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n                mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n                mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n                mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n                mstore(0x40, add(m, 0x100))\\n                let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n                let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n                let _a := div(mul(a, magic), shift)\\n                r := div(mload(add(m,sub(255,_a))), shift)\\n                r := add(r, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n                // where a is a power of two, result needs to be incremented. we use the power of two trick here: if(arg & arg-1 == 0) ++r;\\n                if eq(and(arg, sub(arg, 1)), 0) {\\n                    r := add(r, 1) \\n                }\\n            }\\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "zero",
                    "parameters": "",
                    "modifiers": "pure",
                    "return": "returns(BigNumber memory)",
                    "body": "function zero(\n    ) internal pure returns(BigNumber memory) {\n        return BigNumber(ZERO, false, 0);\n    }",
                    "start": "830",
                    "end": "833",
                    "class": "BigNumbers",
                    "signature": "returns(BigNumber memory) zero",
                    "full_signature": "function zero() internal pure returns(BigNumber memory)",
                    "class_method_signature": "BigNumbers.zero",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity 0.8.17;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Returns a BigNumber representing zero.\n * @dev Creates and returns a new BigNumber struct initialized with:\n * - value: ZERO constant\n * - negative: false\n * - bitlen: 0\n * @return BigNumber memory A BigNumber struct representing zero.\n */",
                    "tdd": "{'function zero(\\n    ) internal pure returns(BigNumber memory) {\\n        return BigNumber(ZERO, false, 0);\\n    }'}",
                    "context": "set()"
                }
            ]
        }
    ],
    "repository/royalty-registry-solidity/contracts/impl/KODAV2Override.sol": [
        {
            "methods": [
                {
                    "identifier": "getKODAV2RoyaltyInfo",
                    "parameters": "address _tokenAddress, uint256 _id, uint256 _amount",
                    "modifiers": "override",
                    "return": "returns (address payable[] memory receivers, uint256[] memory amounts)",
                    "body": "function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\n        external\n        view\n        override\n        returns (address payable[] memory receivers, uint256[] memory amounts)\n    {\n        // Get the edition the token is part of\n        uint256 _editionNumber = IKODAV2(_tokenAddress).editionOfTokenId(_id);\n        require(_editionNumber > 0, \"Edition not found for token ID\");\n\n        // Get existing artist commission\n        (address artistAccount, uint256 artistCommissionRate) = IKODAV2(_tokenAddress).artistCommission(_editionNumber);\n\n        // work out the expected royalty payment\n        uint256 totalRoyaltyToPay = (_amount / modulo) * creatorRoyaltiesFee;\n\n        // Get optional commission set against the edition and work out the expected commission\n        (uint256 optionalCommissionRate, address optionalCommissionRecipient) =\n            IKODAV2(_tokenAddress).editionOptionalCommission(_editionNumber);\n        if (optionalCommissionRate > 0) {\n            receivers = new address payable[](2);\n            amounts = new uint256[](2);\n\n            uint256 totalCommission = artistCommissionRate + optionalCommissionRate;\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = (totalRoyaltyToPay / totalCommission) * artistCommissionRate;\n\n            // Add optional splits\n            receivers[1] = payable(optionalCommissionRecipient);\n            amounts[1] = (totalRoyaltyToPay / totalCommission) * optionalCommissionRate;\n        } else {\n            receivers = new address payable[](1);\n            amounts = new uint256[](1);\n\n            // Add the artist and commission\n            receivers[0] = payable(artistAccount);\n            amounts[0] = totalRoyaltyToPay;\n        }\n\n        return (receivers, amounts);\n    }",
                    "start": "27",
                    "end": "69",
                    "class": "KODAV2Override",
                    "signature": "returns (address payable[] memory receivers, uint256[] memory amounts) getKODAV2RoyaltyInfoaddress _tokenAddress, uint256 _id, uint256 _amount",
                    "full_signature": "function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount) external  override returns (address payable[] memory receivers, uint256[] memory amounts)",
                    "class_method_signature": "KODAV2Override.getKODAV2RoyaltyInfoaddress _tokenAddress, uint256 _id, uint256 _amount",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "external",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/access/Ownable.sol\";",
                        "import \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";",
                        "import \"../specs/IKODAV2Override.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Gets royalty information for a KODA V2 token.\n * @dev Calculates royalty distribution between artist and optional commission recipients.\n * \n * Steps:\n * 1. Get the edition number for the given token ID.\n * 2. Require that the edition exists (edition number > 0).\n * \n * 3. Get the artist's commission details for the edition.\n * 4. Calculate the total royalty payment based on the input amount.\n * \n * 5. Check for optional commission settings on the edition:\n *    - If optional commission exists:\n *      a. Create arrays for 2 receivers and amounts\n *      b. Calculate total commission rate (artist + optional)\n *      c. Distribute royalties between artist and optional recipient\n *    - If no optional commission:\n *      a. Create arrays for 1 receiver and amount\n *      b. Assign all royalties to the artist\n * \n * @param _tokenAddress Address of the KODA V2 token contract\n * @param _id Token ID to check\n * @param _amount Amount to calculate royalties from\n * @return receivers Array of payable addresses to receive royalties\n * @return amounts Array of corresponding royalty amounts\n */",
                    "tdd": "{'function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\\n        external\\n        view\\n        override\\n        returns (address payable[] memory receivers, uint256[] memory amounts)\\n    {\\n        // Get the edition the token is part of\\n        uint256 _editionNumber = IKODAV2(_tokenAddress).editionOfTokenId(_id);\\n        require(_editionNumber > 0, \"Edition not found for token ID\");\\n\\n        // Get existing artist commission\\n        (address artistAccount, uint256 artistCommissionRate) = IKODAV2(_tokenAddress).artistCommission(_editionNumber);\\n\\n        // work out the expected royalty payment\\n        uint256 totalRoyaltyToPay = (_amount / modulo) * creatorRoyaltiesFee;\\n\\n        // Get optional commission set against the edition and work out the expected commission\\n        (uint256 optionalCommissionRate, address optionalCommissionRecipient) =\\n            IKODAV2(_tokenAddress).editionOptionalCommission(_editionNumber);\\n        if (optionalCommissionRate > 0) {\\n            receivers = new address payable[](2);\\n            amounts = new uint256[](2);\\n\\n            uint256 totalCommission = artistCommissionRate + optionalCommissionRate;\\n\\n            // Add the artist and commission\\n            receivers[0] = payable(artistAccount);\\n            amounts[0] = (totalRoyaltyToPay / totalCommission) * artistCommissionRate;\\n\\n            // Add optional splits\\n            receivers[1] = payable(optionalCommissionRecipient);\\n            amounts[1] = (totalRoyaltyToPay / totalCommission) * optionalCommissionRate;\\n        } else {\\n            receivers = new address payable[](1);\\n            amounts = new uint256[](1);\\n\\n            // Add the artist and commission\\n            receivers[0] = payable(artistAccount);\\n            amounts[0] = totalRoyaltyToPay;\\n        }\\n\\n        return (receivers, amounts);\\n    }'}",
                    "context": "{'function getKODAV2RoyaltyInfo(address _tokenAddress, uint256 _id, uint256 _amount)\\n        external\\n        view\\n        returns (address payable[] memory, uint256[] memory);', 'function editionOptionalCommission(uint256 _editionNumber)\\n        external\\n        view\\n        returns (uint256 _rate, address _recipient);', 'function editionOfTokenId(uint256 _tokenId) external view returns (uint256 _editionNumber);', 'function artistCommission(uint256 _editionNumber)\\n        external\\n        view\\n        returns (address _artistAccount, uint256 _artistCommission);'}"
                },
                {
                    "identifier": "updateCreatorRoyalties",
                    "parameters": "uint256 _creatorRoyaltiesFee",
                    "modifiers": "onlyOwner",
                    "return": "",
                    "body": "function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external override onlyOwner {\n        emit CreatorRoyaltiesFeeUpdated(creatorRoyaltiesFee, _creatorRoyaltiesFee);\n        creatorRoyaltiesFee = _creatorRoyaltiesFee;\n    }",
                    "start": "71",
                    "end": "74",
                    "class": "KODAV2Override",
                    "signature": " updateCreatorRoyaltiesuint256 _creatorRoyaltiesFee",
                    "full_signature": "function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external  onlyOwner",
                    "class_method_signature": "KODAV2Override.updateCreatorRoyaltiesuint256 _creatorRoyaltiesFee",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "external",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/access/Ownable.sol\";",
                        "import \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";",
                        "import \"../specs/IKODAV2Override.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Updates the creator royalties fee percentage.\n * @dev Can only be called by the contract owner.\n * @param _creatorRoyaltiesFee The new creator royalties fee to be set.\n * \n * Emits a `CreatorRoyaltiesFeeUpdated` event with both old and new fee values.\n * Updates the `creatorRoyaltiesFee` state variable with the new value.\n */",
                    "tdd": "{'function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external override onlyOwner {\\n        emit CreatorRoyaltiesFeeUpdated(creatorRoyaltiesFee, _creatorRoyaltiesFee);\\n        creatorRoyaltiesFee = _creatorRoyaltiesFee;\\n    }'}",
                    "context": "{'event CreatorRoyaltiesFeeUpdated(uint256 _oldCreatorRoyaltiesFee, uint256 _newCreatorRoyaltiesFee);', 'function updateCreatorRoyalties(uint256 _creatorRoyaltiesFee) external;', 'modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }'}"
                }
            ]
        }
    ],
    "repository/royalty-registry-solidity/contracts/impl/ZoraOverride.sol": [
        {
            "methods": [
                {
                    "identifier": "convertBidShares",
                    "parameters": "address media, uint256 tokenId",
                    "modifiers": "override",
                    "return": "returns (address payable[] memory receivers, uint256[] memory bps)",
                    "body": "function convertBidShares(address media, uint256 tokenId)\n        public\n        view\n        override\n        returns (address payable[] memory receivers, uint256[] memory bps)\n    {\n        IZoraMarket.ZoraBidShares memory bidShares =\n            IZoraMarket(IZoraMedia(media).marketContract()).bidSharesForToken(tokenId);\n\n        // Get the total length of receivers/bps\n        uint256 totalLength = 0;\n\n        // Note: We do not support previous owner bps because it requires recalculation/sell-on support\n        // Only Zora marketplace does this properly\n        // if (bidShares.prevOwner.value != 0) totalLength++;\n\n        if (bidShares.creator.value != 0) totalLength++;\n\n        // NOTE: We do not support owner bps because these are expected to be handled by the individual market\n        // implementations and are not truly royalties\n        // if (bidShares.owner.value != 0) totalLength++;\n\n        receivers = new address payable[](totalLength);\n        bps = new uint256[](totalLength);\n\n        if (bidShares.creator.value != 0) {\n            receivers[0] = payable(IZoraMedia(media).tokenCreators(tokenId));\n            bps[0] = bidShares.creator.value / (10 ** (18 - 2));\n        }\n\n        return (receivers, bps);\n    }",
                    "start": "21",
                    "end": "52",
                    "class": "ZoraOverride",
                    "signature": "returns (address payable[] memory receivers, uint256[] memory bps) convertBidSharesaddress media, uint256 tokenId",
                    "full_signature": "function convertBidShares(address media, uint256 tokenId) public  override returns (address payable[] memory receivers, uint256[] memory bps)",
                    "class_method_signature": "ZoraOverride.convertBidSharesaddress media, uint256 tokenId",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "public",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";",
                        "import \"../specs/IZoraOverride.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Converts Zora bid shares into royalty receiver addresses and basis points.\n * @dev Only supports creator shares, excludes previous owner and owner shares.\n * @param media The address of the Zora media contract.\n * @param tokenId The ID of the token to query bid shares for.\n * @return receivers Array of payable addresses that should receive royalties.\n * @return bps Array of basis points representing royalty percentages for each receiver.\n *\n * Steps:\n * 1. Query Zora market contract for bid shares of the specified token.\n * 2. Calculate total number of royalty receivers (only counting creator shares).\n * 3. Initialize arrays for receivers and basis points with calculated length.\n * 4. If creator shares exist:\n *    a. Set first receiver as token creator's address.\n *    b. Convert creator share value from 18 decimal places to basis points (2 decimal places).\n * 5. Return the receivers and basis points arrays.\n *\n * Note:\n * - Previous owner shares are not supported as they require sell-on support.\n * - Owner shares are not considered true royalties and are handled by market implementations.\n */",
                    "tdd": "{'function convertBidShares(address media, uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address payable[] memory receivers, uint256[] memory bps)\\n    {\\n        IZoraMarket.ZoraBidShares memory bidShares =\\n            IZoraMarket(IZoraMedia(media).marketContract()).bidSharesForToken(tokenId);\\n\\n        // Get the total length of receivers/bps\\n        uint256 totalLength = 0;\\n\\n        // Note: We do not support previous owner bps because it requires recalculation/sell-on support\\n        // Only Zora marketplace does this properly\\n        // if (bidShares.prevOwner.value != 0) totalLength++;\\n\\n        if (bidShares.creator.value != 0) totalLength++;\\n\\n        // NOTE: We do not support owner bps because these are expected to be handled by the individual market\\n        // implementations and are not truly royalties\\n        // if (bidShares.owner.value != 0) totalLength++;\\n\\n        receivers = new address payable[](totalLength);\\n        bps = new uint256[](totalLength);\\n\\n        if (bidShares.creator.value != 0) {\\n            receivers[0] = payable(IZoraMedia(media).tokenCreators(tokenId));\\n            bps[0] = bidShares.creator.value / (10 ** (18 - 2));\\n        }\\n\\n        return (receivers, bps);\\n    }'}",
                    "context": "{'function marketContract() external view returns (address);', 'function tokenCreators(uint256 tokenId) external view returns (address);', 'function convertBidShares(address media, uint256 tokenId)\\n        external\\n        view\\n        returns (address payable[] memory, uint256[] memory);', 'function bidSharesForToken(uint256 tokenId) external view returns (ZoraBidShares memory);', 'struct ZoraBidShares {\\n        // % of sale value that goes to the _previous_ owner of the nft\\n        ZoraDecimal prevOwner;\\n        // % of sale value that goes to the original creator of the nft\\n        ZoraDecimal creator;\\n        // % of sale value that goes to the seller (current owner) of the nft\\n        ZoraDecimal owner;\\n    }'}"
                }
            ]
        }
    ],
    "repository/solidity-merkle-trees/src/MerkleMountainRange.sol": [
        {
            "methods": [
                {
                    "identifier": "VerifyProof",
                    "parameters": "bytes32 root, bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 mmrSize",
                    "modifiers": "pure",
                    "return": "returns (bool)",
                    "body": "function VerifyProof(\n        bytes32 root,\n        bytes32[] memory proof,\n        MmrLeaf[] memory leaves,\n        uint256 mmrSize\n    ) internal pure returns (bool) {\n        return root == CalculateRoot(proof, leaves, mmrSize);\n    }",
                    "start": "27",
                    "end": "34",
                    "class": "MerkleMountainRange",
                    "signature": "returns (bool) VerifyProofbytes32 root, bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 mmrSize",
                    "full_signature": "function VerifyProof(bytes32 root, bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 mmrSize) internal pure returns (bool)",
                    "class_method_signature": "MerkleMountainRange.VerifyProofbytes32 root, bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 mmrSize",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Verifies a Merkle Mountain Range (MMR) proof by comparing the calculated root with the provided root.\n * \n * @param root The expected root hash to verify against.\n * @param proof Array of proof elements needed for verification.\n * @param leaves Array of MMR leaves containing the data to be verified.\n * @param mmrSize The size of the MMR at the time of proof generation.\n * \n * @return bool Returns true if the calculated root matches the provided root, false otherwise.\n * \n * The function works by:\n * 1. Calculating the root hash using the provided proof, leaves, and MMR size.\n * 2. Comparing the calculated root with the provided root.\n * 3. Returning the result of the comparison.\n */",
                    "tdd": "{'function VerifyProof(\\n        bytes32 root,\\n        bytes32[] memory proof,\\n        MmrLeaf[] memory leaves,\\n        uint256 mmrSize\\n    ) internal pure returns (bool) {\\n        return root == CalculateRoot(proof, leaves, mmrSize);\\n    }'}",
                    "context": "{'function VerifyProof(\\n        bytes32 root,\\n        Node[][] memory proof,\\n        Node[] memory leaves\\n    ) internal pure returns (bool) {\\n        return root == CalculateRoot(proof, leaves);\\n    }', 'function CalculateRoot(\\n        Node[][] memory proof,\\n        Node[] memory leaves\\n    ) internal pure returns (bytes32) {\\n        // holds the output from hashing a previous layer\\n        Node[] memory next_layer = new Node[](0);\\n\\n        // merge leaves\\n        proof[0] = mergeSort(leaves, proof[0]);\\n\\n        uint256 proof_length = proof.length;\\n        for (uint256 height = 0; height < proof_length; height++) {\\n            Node[] memory current_layer = new Node[](0);\\n\\n            if (next_layer.length == 0) {\\n                current_layer = proof[height];\\n            } else {\\n                current_layer = mergeSort(proof[height], next_layer);\\n            }\\n\\n            next_layer = new Node[](div_ceil(current_layer.length, 2));\\n\\n            uint256 p = 0;\\n            uint256 current_layer_length = current_layer.length;\\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\\n                if (index + 1 >= current_layer_length) {\\n                    Node memory node = current_layer[index];\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    next_layer[p] = node;\\n                } else {\\n                    Node memory node;\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    node.node = _optimizedHash(\\n                        current_layer[index].node,\\n                        current_layer[index + 1].node\\n                    );\\n                    next_layer[p] = node;\\n                    unchecked {\\n                        p++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // we should have arrived at the root node\\n        require(next_layer.length == 1);\\n\\n        return next_layer[0].node;\\n    }'}"
                },
                {
                    "identifier": "CalculateRoot",
                    "parameters": "bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 leafCount",
                    "modifiers": "pure",
                    "return": "returns (bytes32)",
                    "body": "function CalculateRoot(\n        bytes32[] memory proof,\n        MmrLeaf[] memory leaves,\n        uint256 leafCount\n    ) internal pure returns (bytes32) {\n        // special handle the only 1 leaf MMR\n        if (leafCount == 1 && leaves.length == 1 && leaves[0].leaf_index == 0) {\n            return leaves[0].hash;\n        }\n\n        uint256[] memory subtrees = subtreeHeights(leafCount);\n        uint256 length = subtrees.length;\n        Iterator memory peakRoots = Iterator(0, new bytes32[](length));\n        Iterator memory proofIter = Iterator(0, proof);\n\n        uint256 current_subtree;\n        LeafIterator memory leafIter = LeafIterator(0, leaves.length);\n\n        for (uint256 p; p < length; ) {\n            uint256 height = subtrees[p];\n            current_subtree += 2 ** height;\n\n            // Get iterators for the current subtree leaves\n            LeafIterator memory subtreeLeaves = getSubtreeLeaves(\n                leaves,\n                leafIter,\n                current_subtree\n            );\n\n            if (subtreeLeaves.length == 0) {\n                if (proofIter.data.length == proofIter.offset) {\n                    break;\n                } else {\n                    push(peakRoots, next(proofIter));\n                }\n            } else if (subtreeLeaves.length == 1 && height == 0) {\n                push(peakRoots, leaves[subtreeLeaves.offset].hash);\n            } else {\n                push(\n                    peakRoots,\n                    CalculateSubtreeRoot(leaves, subtreeLeaves, proofIter, height)\n                );\n            }\n\n            unchecked {\n                ++p;\n            }\n        }\n\n        unchecked {\n            peakRoots.offset--;\n        }\n\n        while (peakRoots.offset != 0) {\n            bytes32 right = previous(peakRoots);\n            bytes32 left = previous(peakRoots);\n            unchecked {\n                ++peakRoots.offset;\n            }\n            peakRoots.data[peakRoots.offset] = keccak256(\n                abi.encodePacked(right, left)\n            );\n        }\n\n        return peakRoots.data[0];\n    }",
                    "start": "42",
                    "end": "107",
                    "class": "MerkleMountainRange",
                    "signature": "returns (bytes32) CalculateRootbytes32[] memory proof, MmrLeaf[] memory leaves, uint256 leafCount",
                    "full_signature": "function CalculateRoot(bytes32[] memory proof, MmrLeaf[] memory leaves, uint256 leafCount) internal pure returns (bytes32)",
                    "class_method_signature": "MerkleMountainRange.CalculateRootbytes32[] memory proof, MmrLeaf[] memory leaves, uint256 leafCount",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Calculates the Merkle Mountain Range (MMR) root hash from given proof and leaves.\n *\n * @param proof Array of proof hashes needed for root calculation.\n * @param leaves Array of MMR leaves containing leaf index and hash.\n * @param leafCount Total number of leaves in the MMR.\n *\n * @return bytes32 The calculated MMR root hash.\n *\n * Steps:\n * 1. Special case handling for single leaf MMR (returns the leaf hash directly).\n * 2. Calculate heights of all subtrees in the MMR.\n * 3. Initialize iterators for peak roots and proof hashes.\n * 4. Initialize leaf iterator to traverse through leaves.\n *\n * 5. For each subtree height:\n *    a. Calculate current subtree size.\n *    b. Get leaves belonging to current subtree.\n *    c. If no leaves in subtree:\n *       - Use next proof hash if available.\n *    d. If single leaf at height 0:\n *       - Use leaf hash directly.\n *    e. Otherwise:\n *       - Calculate subtree root recursively.\n *\n * 6. Combine peak roots iteratively:\n *    a. Pop two rightmost peaks.\n *    b. Hash them together.\n *    c. Push result back as new peak.\n *\n * 7. Return the final remaining peak as the MMR root.\n */",
                    "tdd": "{'function CalculateRoot(\\n        bytes32[] memory proof,\\n        MmrLeaf[] memory leaves,\\n        uint256 leafCount\\n    ) internal pure returns (bytes32) {\\n        // special handle the only 1 leaf MMR\\n        if (leafCount == 1 && leaves.length == 1 && leaves[0].leaf_index == 0) {\\n            return leaves[0].hash;\\n        }\\n\\n        uint256[] memory subtrees = subtreeHeights(leafCount);\\n        uint256 length = subtrees.length;\\n        Iterator memory peakRoots = Iterator(0, new bytes32[](length));\\n        Iterator memory proofIter = Iterator(0, proof);\\n\\n        uint256 current_subtree;\\n        LeafIterator memory leafIter = LeafIterator(0, leaves.length);\\n\\n        for (uint256 p; p < length; ) {\\n            uint256 height = subtrees[p];\\n            current_subtree += 2 ** height;\\n\\n            // Get iterators for the current subtree leaves\\n            LeafIterator memory subtreeLeaves = getSubtreeLeaves(\\n                leaves,\\n                leafIter,\\n                current_subtree\\n            );\\n\\n            if (subtreeLeaves.length == 0) {\\n                if (proofIter.data.length == proofIter.offset) {\\n                    break;\\n                } else {\\n                    push(peakRoots, next(proofIter));\\n                }\\n            } else if (subtreeLeaves.length == 1 && height == 0) {\\n                push(peakRoots, leaves[subtreeLeaves.offset].hash);\\n            } else {\\n                push(\\n                    peakRoots,\\n                    CalculateSubtreeRoot(leaves, subtreeLeaves, proofIter, height)\\n                );\\n            }\\n\\n            unchecked {\\n                ++p;\\n            }\\n        }\\n\\n        unchecked {\\n            peakRoots.offset--;\\n        }\\n\\n        while (peakRoots.offset != 0) {\\n            bytes32 right = previous(peakRoots);\\n            bytes32 left = previous(peakRoots);\\n            unchecked {\\n                ++peakRoots.offset;\\n            }\\n            peakRoots.data[peakRoots.offset] = keccak256(\\n                abi.encodePacked(right, left)\\n            );\\n        }\\n\\n        return peakRoots.data[0];\\n    }'}",
                    "context": "{'function CalculateRoot(\\n        Node[][] memory proof,\\n        Node[] memory leaves\\n    ) internal pure returns (bytes32) {\\n        // holds the output from hashing a previous layer\\n        Node[] memory next_layer = new Node[](0);\\n\\n        // merge leaves\\n        proof[0] = mergeSort(leaves, proof[0]);\\n\\n        uint256 proof_length = proof.length;\\n        for (uint256 height = 0; height < proof_length; height++) {\\n            Node[] memory current_layer = new Node[](0);\\n\\n            if (next_layer.length == 0) {\\n                current_layer = proof[height];\\n            } else {\\n                current_layer = mergeSort(proof[height], next_layer);\\n            }\\n\\n            next_layer = new Node[](div_ceil(current_layer.length, 2));\\n\\n            uint256 p = 0;\\n            uint256 current_layer_length = current_layer.length;\\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\\n                if (index + 1 >= current_layer_length) {\\n                    Node memory node = current_layer[index];\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    next_layer[p] = node;\\n                } else {\\n                    Node memory node;\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    node.node = _optimizedHash(\\n                        current_layer[index].node,\\n                        current_layer[index + 1].node\\n                    );\\n                    next_layer[p] = node;\\n                    unchecked {\\n                        p++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // we should have arrived at the root node\\n        require(next_layer.length == 1);\\n\\n        return next_layer[0].node;\\n    }'}"
                },
                {
                    "identifier": "difference",
                    "parameters": "uint256[] memory left, uint256[] memory right",
                    "modifiers": "pure",
                    "return": "returns (uint256[] memory)",
                    "body": "function difference(\n        uint256[] memory left,\n        uint256[] memory right\n    ) internal pure returns (uint256[] memory) {\n        uint256 length = left.length;\n        uint256 rightLength = right.length;\n\n        uint256[] memory diff = new uint256[](length);\n        uint256 d;\n        for (uint256 i; i < length; ) {\n            bool found;\n            for (uint256 j; j < rightLength; ) {\n                if (left[i] == right[j]) {\n                    found = true;\n                    break;\n                }\n\n                unchecked {\n                    ++j;\n                }\n            }\n\n            if (!found) {\n                diff[d] = left[i];\n                d++;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // resize array?, sigh solidity.\n        uint256 excess = length - d;\n        assembly {\n            mstore(diff, sub(mload(diff), excess))\n        }\n\n        return diff;\n    }",
                    "start": "228",
                    "end": "267",
                    "class": "MerkleMountainRange",
                    "signature": "returns (uint256[] memory) differenceuint256[] memory left, uint256[] memory right",
                    "full_signature": "function difference(uint256[] memory left, uint256[] memory right) internal pure returns (uint256[] memory)",
                    "class_method_signature": "MerkleMountainRange.differenceuint256[] memory left, uint256[] memory right",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Computes the difference between two arrays of unsigned integers.\n * @dev Returns elements in the left array that are not present in the right array.\n *\n * Steps:\n * 1. Initialize variables for array lengths and create a result array.\n * 2. Iterate through each element in the left array.\n * 3. For each element, check if it exists in the right array.\n * 4. If not found, add the element to the difference array.\n * 5. Use unchecked blocks for gas optimization on loop increments.\n * 6. Resize the difference array to remove unused slots using assembly.\n * 7. Return the final difference array.\n *\n * @param left The first array of unsigned integers.\n * @param right The second array of unsigned integers to compare against.\n * @return diff An array containing elements from left that are not in right.\n */",
                    "tdd": "{'function difference(\\n        uint256[] memory left,\\n        uint256[] memory right\\n    ) internal pure returns (uint256[] memory) {\\n        uint256 length = left.length;\\n        uint256 rightLength = right.length;\\n\\n        uint256[] memory diff = new uint256[](length);\\n        uint256 d;\\n        for (uint256 i; i < length; ) {\\n            bool found;\\n            for (uint256 j; j < rightLength; ) {\\n                if (left[i] == right[j]) {\\n                    found = true;\\n                    break;\\n                }\\n\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n\\n            if (!found) {\\n                diff[d] = left[i];\\n                d++;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // resize array?, sigh solidity.\\n        uint256 excess = length - d;\\n        assembly {\\n            mstore(diff, sub(mload(diff), excess))\\n        }\\n\\n        return diff;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "siblingIndices",
                    "parameters": "uint256[] memory indices",
                    "modifiers": "pure",
                    "return": "returns (uint256[] memory)",
                    "body": "function siblingIndices(\n        uint256[] memory indices\n    ) internal pure returns (uint256[] memory) {\n        uint256 length = indices.length;\n        uint256[] memory siblings = new uint256[](length);\n\n        for (uint256 i; i < length; ) {\n            uint256 index = indices[i];\n            if (index == 0) {\n                siblings[i] = index + 1;\n            } else if (index % 2 == 0) {\n                siblings[i] = index + 1;\n            } else {\n                siblings[i] = index - 1;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return siblings;\n    }",
                    "start": "275",
                    "end": "297",
                    "class": "MerkleMountainRange",
                    "signature": "returns (uint256[] memory) siblingIndicesuint256[] memory indices",
                    "full_signature": "function siblingIndices(uint256[] memory indices) internal pure returns (uint256[] memory)",
                    "class_method_signature": "MerkleMountainRange.siblingIndicesuint256[] memory indices",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Calculates sibling indices for a given array of indices.\n * @dev For each index in the input array:\n *      - If index is 0, sibling is index + 1\n *      - If index is even, sibling is index + 1\n *      - If index is odd, sibling is index - 1\n * @param indices Array of input indices to calculate siblings for\n * @return siblings Array of calculated sibling indices\n *\n * Implementation:\n * 1. Initialize output array with same length as input\n * 2. Iterate through each index in input array\n * 3. For each index, determine sibling based on rules above\n * 4. Use unchecked block for index increment to save gas\n * 5. Return the resulting siblings array\n */",
                    "tdd": "{'function siblingIndices(\\n        uint256[] memory indices\\n    ) internal pure returns (uint256[] memory) {\\n        uint256 length = indices.length;\\n        uint256[] memory siblings = new uint256[](length);\\n\\n        for (uint256 i; i < length; ) {\\n            uint256 index = indices[i];\\n            if (index == 0) {\\n                siblings[i] = index + 1;\\n            } else if (index % 2 == 0) {\\n                siblings[i] = index + 1;\\n            } else {\\n                siblings[i] = index - 1;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return siblings;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "mmrLeafToNode",
                    "parameters": "MmrLeaf[] memory leaves, LeafIterator memory leafIter",
                    "modifiers": "pure",
                    "return": "returns (Node[] memory, uint256[] memory)",
                    "body": "function mmrLeafToNode(\n        MmrLeaf[] memory leaves,\n        LeafIterator memory leafIter\n    ) internal pure returns (Node[] memory, uint256[] memory) {\n        uint256 length = leafIter.length;\n        uint256 offset = leafIter.offset;\n\n        Node[] memory nodes = new Node[](length);\n        uint256[] memory indices = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            nodes[i] = Node(leaves[offset + i].k_index, leaves[offset + i].hash);\n            indices[i] = leaves[offset + i].k_index;\n        }\n\n        return (nodes, indices);\n    }",
                    "start": "338",
                    "end": "354",
                    "class": "MerkleMountainRange",
                    "signature": "returns (Node[] memory, uint256[] memory) mmrLeafToNodeMmrLeaf[] memory leaves, LeafIterator memory leafIter",
                    "full_signature": "function mmrLeafToNode(MmrLeaf[] memory leaves, LeafIterator memory leafIter) internal pure returns (Node[] memory, uint256[] memory)",
                    "class_method_signature": "MerkleMountainRange.mmrLeafToNodeMmrLeaf[] memory leaves, LeafIterator memory leafIter",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Converts an array of MMR leaves to nodes with their indices.\n *\n * @param leaves The array of MMR leaves to process.\n * @param leafIter Contains the length and offset for processing the leaves.\n *\n * Steps:\n * 1. Extract the processing length and offset from leafIter.\n * 2. Initialize arrays for nodes and indices with the specified length.\n * 3. Iterate through each leaf in the specified range:\n *    - Create a Node from each leaf's k_index and hash.\n *    - Store the leaf's k_index in the indices array.\n * 4. Return the arrays of nodes and indices.\n *\n * @return nodes Array of Nodes created from the leaves.\n * @return indices Array of k_index values from the leaves.\n */",
                    "tdd": "{'function mmrLeafToNode(\\n        MmrLeaf[] memory leaves,\\n        LeafIterator memory leafIter\\n    ) internal pure returns (Node[] memory, uint256[] memory) {\\n        uint256 length = leafIter.length;\\n        uint256 offset = leafIter.offset;\\n\\n        Node[] memory nodes = new Node[](length);\\n        uint256[] memory indices = new uint256[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            nodes[i] = Node(leaves[offset + i].k_index, leaves[offset + i].hash);\\n            indices[i] = leaves[offset + i].k_index;\\n        }\\n\\n        return (nodes, indices);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "leavesForSubtree",
                    "parameters": "MmrLeaf[] memory leaves, uint256 leafIndex",
                    "modifiers": "pure",
                    "return": "returns (LeafIterator memory, LeafIterator memory)",
                    "body": "function leavesForSubtree(\n        MmrLeaf[] memory leaves,\n        uint256 leafIndex\n    ) internal pure returns (LeafIterator memory, LeafIterator memory) {\n        uint256 p;\n        uint256 length = leaves.length;\n\n        // Find the position where leafIndex splits the leaves\n        for (; p < length; p++) {\n            if (leafIndex <= leaves[p].leaf_index) {\n                break;\n            }\n        }\n\n        // Create iterators instead of copying into arrays\n        LeafIterator memory left = LeafIterator(0, p);\n        LeafIterator memory right = LeafIterator(p, length - p);\n\n        return (left, right);\n    }",
                    "start": "363",
                    "end": "382",
                    "class": "MerkleMountainRange",
                    "signature": "returns (LeafIterator memory, LeafIterator memory) leavesForSubtreeMmrLeaf[] memory leaves, uint256 leafIndex",
                    "full_signature": "function leavesForSubtree(MmrLeaf[] memory leaves, uint256 leafIndex) internal pure returns (LeafIterator memory, LeafIterator memory)",
                    "class_method_signature": "MerkleMountainRange.leavesForSubtreeMmrLeaf[] memory leaves, uint256 leafIndex",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": " \n/**\n * @notice Splits an array of MMR leaves into two iterators at the specified leaf index.  \n *  \n * @param leaves The array of MMR leaves to split.  \n * @param leafIndex The index at which to split the leaves array.  \n *  \n * @return left A LeafIterator representing the left portion of the split (from start to leafIndex).  \n * @return right A LeafIterator representing the right portion of the split (from leafIndex to end).  \n *  \n * Steps:  \n * 1. Initialize variables for tracking position (p) and the length of the leaves array.  \n * 2. Iterate through the leaves to find the split position where leafIndex <= leaves[p].leaf_index.  \n * 3. Create a left iterator covering the range from the start to the split position.  \n * 4. Create a right iterator covering the range from the split position to the end.  \n * 5. Return the left and right iterators.  \n */  ",
                    "tdd": "{'function leavesForSubtree(\\n        MmrLeaf[] memory leaves,\\n        uint256 leafIndex\\n    ) internal pure returns (LeafIterator memory, LeafIterator memory) {\\n        uint256 p;\\n        uint256 length = leaves.length;\\n\\n        // Find the position where leafIndex splits the leaves\\n        for (; p < length; p++) {\\n            if (leafIndex <= leaves[p].leaf_index) {\\n                break;\\n            }\\n        }\\n\\n        // Create iterators instead of copying into arrays\\n        LeafIterator memory left = LeafIterator(0, p);\\n        LeafIterator memory right = LeafIterator(p, length - p);\\n\\n        return (left, right);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "push",
                    "parameters": "Iterator memory iterator, bytes32 data",
                    "modifiers": "pure",
                    "return": "",
                    "body": "function push(Iterator memory iterator, bytes32 data) internal pure {\n        iterator.data[iterator.offset] = data;\n        unchecked {\n            ++iterator.offset;\n        }\n    }",
                    "start": "384",
                    "end": "389",
                    "class": "MerkleMountainRange",
                    "signature": " pushIterator memory iterator, bytes32 data",
                    "full_signature": "function push(Iterator memory iterator, bytes32 data) internal pure",
                    "class_method_signature": "MerkleMountainRange.pushIterator memory iterator, bytes32 data",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";",
                        "import \"./MerkleMultiProof.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Pushes a new bytes32 element to the iterator's data array and increments the offset.\n * @dev Uses unchecked block to optimize gas usage for offset increment.\n * @param iterator The iterator struct containing data array and offset.\n * @param data The bytes32 data to be added to the iterator's array.\n */",
                    "tdd": "{'function push(Iterator memory iterator, bytes32 data) internal pure {\\n        iterator.data[iterator.offset] = data;\\n        unchecked {\\n            ++iterator.offset;\\n        }\\n    }'}",
                    "context": "set()"
                }
            ]
        }
    ],
    "repository/solidity-merkle-trees/src/MerklePatricia.sol": [
        {
            "methods": [
                {
                    "identifier": "VerifySubstrateProof",
                    "parameters": "bytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "modifiers": "pure",
                    "return": "returns (StorageValue[] memory)",
                    "body": "function VerifySubstrateProof(\n        bytes32 root,\n        bytes[] memory proof,\n        bytes[] memory keys\n    ) public pure returns (StorageValue[] memory) {\n        StorageValue[] memory values = new StorageValue[](keys.length);\n        TrieNode[] memory nodes = new TrieNode[](proof.length);\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            nodes[i] = TrieNode(keccak256(proof[i]), proof[i]);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            values[i].key = keys[i];\n            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);\n            NodeKind memory node = SubstrateTrieDB.decodeNodeKind(\n                TrieDB.get(nodes, root)\n            );\n\n            // This loop is unbounded so that an adversary cannot insert a deeply nested key in the trie\n            // and successfully convince us of it's non-existence, if we consume the block gas limit while\n            // traversing the trie, then the transaction should revert.\n            for (uint256 j = 1; j > 0; j++) {\n                NodeHandle memory nextNode;\n\n                if (TrieDB.isLeaf(node)) {\n                    Leaf memory leaf = SubstrateTrieDB.decodeLeaf(node);\n                    if (NibbleSliceOps.eq(leaf.key, keyNibbles)) {\n                        values[i].value = TrieDB.load(nodes, leaf.value);\n                    }\n                    break;\n                } else if (TrieDB.isNibbledBranch(node)) {\n                    NibbledBranch memory nibbled = SubstrateTrieDB\n                        .decodeNibbledBranch(node);\n                    uint256 nibbledBranchKeyLength = NibbleSliceOps.len(\n                        nibbled.key\n                    );\n                    if (!NibbleSliceOps.startsWith(keyNibbles, nibbled.key)) {\n                        break;\n                    }\n\n                    if (\n                        NibbleSliceOps.len(keyNibbles) == nibbledBranchKeyLength\n                    ) {\n                        if (Option.isSome(nibbled.value)) {\n                            values[i].value = TrieDB.load(\n                                nodes,\n                                nibbled.value.value\n                            );\n                        }\n                        break;\n                    } else {\n                        uint256 index = NibbleSliceOps.at(\n                            keyNibbles,\n                            nibbledBranchKeyLength\n                        );\n                        NodeHandleOption memory handle = nibbled.children[\n                            index\n                        ];\n                        if (Option.isSome(handle)) {\n                            keyNibbles = NibbleSliceOps.mid(\n                                keyNibbles,\n                                nibbledBranchKeyLength + 1\n                            );\n                            nextNode = handle.value;\n                        } else {\n                            break;\n                        }\n                    }\n                } else if (TrieDB.isEmpty(node)) {\n                    break;\n                }\n\n                node = SubstrateTrieDB.decodeNodeKind(\n                    TrieDB.load(nodes, nextNode)\n                );\n            }\n        }\n\n        return values;\n    }",
                    "start": "28",
                    "end": "108",
                    "class": "MerklePatricia",
                    "signature": "returns (StorageValue[] memory) VerifySubstrateProofbytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "full_signature": "function VerifySubstrateProof(bytes32 root, bytes[] memory proof, bytes[] memory keys) public  pure returns (StorageValue[] memory)",
                    "class_method_signature": "MerklePatricia.VerifySubstrateProofbytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "public",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"./trie/Node.sol\";",
                        "import \"./trie/Option.sol\";",
                        "import \"./trie/NibbleSlice.sol\";",
                        "import \"./trie/TrieDB.sol\";",
                        "import \"./trie/substrate/SubstrateTrieDB.sol\";",
                        "import \"./trie/ethereum/EthereumTrieDB.sol\";",
                        "import \"./Types.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Verifies a Substrate proof against a given root and returns storage values.\n * @dev This function processes a Merkle proof to verify the existence of key-value pairs in a Substrate trie.\n *\n * Steps:\n * 1. Initialize arrays for storage values and trie nodes.\n * 2. Hash each proof element and store as trie nodes.\n *\n * 3. For each key:\n *    a. Initialize a nibble slice for key processing.\n *    b. Decode the root node from the trie.\n *\n * 4. Perform an unbounded trie traversal:\n *    a. If node is a leaf:\n *       - Check if leaf key matches the target key.\n *       - If match found, store the value and break.\n *    b. If node is a nibbled branch:\n *       - Check if key starts with branch prefix.\n *       - If full key matches branch prefix and branch has value, store it.\n *       - Otherwise, follow the appropriate child node.\n *    c. If node is empty, break the traversal.\n *\n * 5. For each step in traversal, decode the next node and continue processing.\n *\n * @param root The root hash of the trie to verify against.\n * @param proof Array of proof elements (encoded nodes).\n * @param keys Array of keys to look up in the trie.\n * @return values Array of StorageValue structs containing key-value pairs found in the trie.\n *\n * Note: The unbounded loop prevents adversaries from creating deep trie structures\n * that could cause gas exhaustion during verification.\n */",
                    "tdd": "{\"function VerifySubstrateProof(\\n        bytes32 root,\\n        bytes[] memory proof,\\n        bytes[] memory keys\\n    ) public pure returns (StorageValue[] memory) {\\n        StorageValue[] memory values = new StorageValue[](keys.length);\\n        TrieNode[] memory nodes = new TrieNode[](proof.length);\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            nodes[i] = TrieNode(keccak256(proof[i]), proof[i]);\\n        }\\n\\n        for (uint256 i = 0; i < keys.length; i++) {\\n            values[i].key = keys[i];\\n            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);\\n            NodeKind memory node = SubstrateTrieDB.decodeNodeKind(\\n                TrieDB.get(nodes, root)\\n            );\\n\\n            // This loop is unbounded so that an adversary cannot insert a deeply nested key in the trie\\n            // and successfully convince us of it's non-existence, if we consume the block gas limit while\\n            // traversing the trie, then the transaction should revert.\\n            for (uint256 j = 1; j > 0; j++) {\\n                NodeHandle memory nextNode;\\n\\n                if (TrieDB.isLeaf(node)) {\\n                    Leaf memory leaf = SubstrateTrieDB.decodeLeaf(node);\\n                    if (NibbleSliceOps.eq(leaf.key, keyNibbles)) {\\n                        values[i].value = TrieDB.load(nodes, leaf.value);\\n                    }\\n                    break;\\n                } else if (TrieDB.isNibbledBranch(node)) {\\n                    NibbledBranch memory nibbled = SubstrateTrieDB\\n                        .decodeNibbledBranch(node);\\n                    uint256 nibbledBranchKeyLength = NibbleSliceOps.len(\\n                        nibbled.key\\n                    );\\n                    if (!NibbleSliceOps.startsWith(keyNibbles, nibbled.key)) {\\n                        break;\\n                    }\\n\\n                    if (\\n                        NibbleSliceOps.len(keyNibbles) == nibbledBranchKeyLength\\n                    ) {\\n                        if (Option.isSome(nibbled.value)) {\\n                            values[i].value = TrieDB.load(\\n                                nodes,\\n                                nibbled.value.value\\n                            );\\n                        }\\n                        break;\\n                    } else {\\n                        uint256 index = NibbleSliceOps.at(\\n                            keyNibbles,\\n                            nibbledBranchKeyLength\\n                        );\\n                        NodeHandleOption memory handle = nibbled.children[\\n                            index\\n                        ];\\n                        if (Option.isSome(handle)) {\\n                            keyNibbles = NibbleSliceOps.mid(\\n                                keyNibbles,\\n                                nibbledBranchKeyLength + 1\\n                            );\\n                            nextNode = handle.value;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                } else if (TrieDB.isEmpty(node)) {\\n                    break;\\n                }\\n\\n                node = SubstrateTrieDB.decodeNodeKind(\\n                    TrieDB.load(nodes, nextNode)\\n                );\\n            }\\n        }\\n\\n        return values;\\n    }\"}",
                    "context": "{'function decodeNibbledBranch(\\n        NodeKind memory node\\n    ) internal pure returns (NibbledBranch memory) {\\n        NibbledBranch memory nibbledBranch;\\n        ByteSlice memory input = node.data;\\n\\n        bool padding = node.nibbleSize % NIBBLE_PER_BYTE != 0;\\n        if (padding && (padLeft(uint8(input.data[input.offset])) != 0)) {\\n            revert(\"Bad Format!\");\\n        }\\n        uint256 nibbleLen = ((node.nibbleSize +\\n            (NibbleSliceOps.NIBBLE_PER_BYTE - 1)) /\\n            NibbleSliceOps.NIBBLE_PER_BYTE);\\n        nibbledBranch.key = NibbleSlice(\\n            Bytes.read(input, nibbleLen),\\n            node.nibbleSize % NIBBLE_PER_BYTE\\n        );\\n\\n        bytes memory bitmapBytes = Bytes.read(input, BITMAP_LENGTH);\\n        uint16 bitmap = uint16(ScaleCodec.decodeUint256(bitmapBytes));\\n\\n        NodeHandleOption memory valueHandle;\\n        if (node.isNibbledHashedValueBranch) {\\n            valueHandle.isSome = true;\\n            valueHandle.value.isHash = true;\\n            valueHandle.value.hash = Bytes.toBytes32(\\n                Bytes.read(input, HASH_lENGTH)\\n            );\\n        } else if (node.isNibbledValueBranch) {\\n            uint256 len = ScaleCodec.decodeUintCompact(input);\\n            valueHandle.isSome = true;\\n            valueHandle.value.isInline = true;\\n            valueHandle.value.inLine = Bytes.read(input, len);\\n        }\\n        nibbledBranch.value = valueHandle;\\n\\n        for (uint256 i = 0; i < 16; i++) {\\n            NodeHandleOption memory childHandle;\\n            if (valueAt(bitmap, i)) {\\n                childHandle.isSome = true;\\n                uint256 len = ScaleCodec.decodeUintCompact(input);\\n                //                revert(string.concat(\"node index: \", Strings.toString(len)));\\n                if (len == HASH_lENGTH) {\\n                    childHandle.value.isHash = true;\\n                    childHandle.value.hash = Bytes.toBytes32(\\n                        Bytes.read(input, HASH_lENGTH)\\n                    );\\n                } else {\\n                    childHandle.value.isInline = true;\\n                    childHandle.value.inLine = Bytes.read(input, len);\\n                }\\n            }\\n            nibbledBranch.children[i] = childHandle;\\n        }\\n\\n        return nibbledBranch;\\n    }', 'function isEmpty(NibbleSlice memory self) internal pure returns (bool) {\\n        return len(self) == 0;\\n    }', 'function isSome(NodeHandleOption memory val) internal pure returns (bool) {\\n        return val.isSome == true;\\n    }', 'function eq(\\n        NibbleSlice memory self,\\n        NibbleSlice memory other\\n    ) internal pure returns (bool) {\\n        return len(self) == len(other) && startsWith(self, other);\\n    }', 'function isEmpty(NodeKind memory node) internal pure returns (bool) {\\n        return node.isEmpty;\\n    }', 'function isSome(ValueOption memory val) internal pure returns (bool) {\\n        return val.isSome == true;\\n    }', 'function decodeNodeKind(\\n        bytes memory encoded\\n    ) internal pure returns (NodeKind memory) {\\n        NodeKind memory node;\\n        ByteSlice memory input = ByteSlice(encoded, 0);\\n        uint8 i = Bytes.readByte(input);\\n\\n        if (i == EMPTY_TRIE) {\\n            node.isEmpty = true;\\n            return node;\\n        }\\n\\n        uint8 mask = i & (0x03 << 6);\\n\\n        if (mask == LEAF_PREFIX_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isLeaf = true;\\n        } else if (mask == BRANCH_WITH_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isNibbledValueBranch = true;\\n        } else if (mask == BRANCH_WITHOUT_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isNibbledBranch = true;\\n        } else if (mask == EMPTY_TRIE) {\\n            if (i & (0x07 << 5) == ALT_HASHING_LEAF_PREFIX_MASK) {\\n                node.nibbleSize = decodeSize(i, input, 3);\\n                node.isHashedLeaf = true;\\n            } else if (i & (0x0F << 4) == ALT_HASHING_BRANCH_WITH_MASK) {\\n                node.nibbleSize = decodeSize(i, input, 4);\\n                node.isNibbledHashedValueBranch = true;\\n            } else {\\n                // do not allow any special encoding\\n                revert(\"Unallowed encoding\");\\n            }\\n        }\\n        node.data = input;\\n\\n        return node;\\n    }', 'function decodeNodeKind(\\n        bytes memory encoded\\n    ) external pure returns (NodeKind memory) {\\n        NodeKind memory node;\\n        ByteSlice memory input = ByteSlice(encoded, 0);\\n        if (Bytes.equals(encoded, HASHED_NULL_NODE)) {\\n            node.isEmpty = true;\\n            return node;\\n        }\\n        RLPReader.RLPItem[] memory itemList = encoded.toRlpItem().toList();\\n        uint256 numItems = itemList.length;\\n        if (numItems == 0) {\\n            node.isEmpty = true;\\n            return node;\\n        } else if (numItems == 2) {\\n            //It may be a leaf or extension\\n            bytes memory key = itemList[0].toBytes();\\n            uint256 prefix;\\n            assembly {\\n                let first := shr(248, mload(add(key, 32)))\\n                prefix := shr(4, first)\\n            }\\n            if (prefix == 2 || prefix == 3) {\\n                node.isLeaf = true;\\n            } else {\\n                node.isExtension = true;\\n            }\\n        } else if (numItems == 17) {\\n            node.isBranch = true;\\n        } else {\\n            revert(\"Invalid data\");\\n        }\\n        node.data = input;\\n        return node;\\n    }', 'function decodeLeaf(\\n        NodeKind memory node\\n    ) internal pure returns (Leaf memory) {\\n        Leaf memory leaf;\\n        ByteSlice memory input = node.data;\\n\\n        bool padding = node.nibbleSize % NIBBLE_PER_BYTE != 0;\\n        if (padding && padLeft(uint8(input.data[input.offset])) != 0) {\\n            revert(\"Bad Format!\");\\n        }\\n        uint256 nibbleLen = (node.nibbleSize +\\n            (NibbleSliceOps.NIBBLE_PER_BYTE - 1)) /\\n            NibbleSliceOps.NIBBLE_PER_BYTE;\\n        bytes memory nibbleBytes = Bytes.read(input, nibbleLen);\\n        leaf.key = NibbleSlice(nibbleBytes, node.nibbleSize % NIBBLE_PER_BYTE);\\n\\n        NodeHandle memory handle;\\n        if (node.isHashedLeaf) {\\n            handle.isHash = true;\\n            handle.hash = Bytes.toBytes32(Bytes.read(input, HASH_lENGTH));\\n        } else {\\n            uint256 len = ScaleCodec.decodeUintCompact(input);\\n            handle.isInline = true;\\n            handle.inLine = Bytes.read(input, len);\\n        }\\n        leaf.value = handle;\\n\\n        return leaf;\\n    }', 'function len(NibbleSlice memory nibble) internal pure returns (uint256) {\\n        return nibble.data.length * NIBBLE_PER_BYTE - nibble.offset;\\n    }', 'function startsWith(\\n        NibbleSlice memory self,\\n        NibbleSlice memory other\\n    ) internal pure returns (bool) {\\n        return commonPrefix(self, other) == len(other);\\n    }', 'function load(\\n        TrieNode[] memory nodes,\\n        NodeHandle memory node\\n    ) internal pure returns (bytes memory) {\\n        if (node.isInline) {\\n            return node.inLine;\\n        } else if (node.isHash) {\\n            return get(nodes, node.hash);\\n        }\\n\\n        return bytes(\"\");\\n    }', 'function get(\\n        TrieNode[] memory nodes,\\n        bytes32 hash\\n    ) internal pure returns (bytes memory) {\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            if (nodes[i].hash == hash) {\\n                return nodes[i].node;\\n            }\\n        }\\n        revert(\"Incomplete Proof!\");\\n    }', 'function at(\\n        NibbleSlice memory self,\\n        uint256 i\\n    ) internal pure returns (uint256) {\\n        uint256 ix = (self.offset + i) / NIBBLE_PER_BYTE;\\n        uint256 pad = (self.offset + i) % NIBBLE_PER_BYTE;\\n        uint8 data = uint8(self.data[ix]);\\n        return (pad == 1) ? data & 0x0F : data >> BITS_PER_NIBBLE;\\n    }', 'function isEmpty(bytes memory item) internal pure returns (bool) {\\n        return item.length > 0 && (item[0] == 0xc0 || item[0] == 0x80);\\n    }', 'function isNibbledBranch(\\n        NodeKind memory node\\n    ) internal pure returns (bool) {\\n        return (node.isNibbledBranch ||\\n            node.isNibbledHashedValueBranch ||\\n            node.isNibbledValueBranch);\\n    }', 'function decodeLeaf(\\n        NodeKind memory node\\n    ) external pure returns (Leaf memory) {\\n        Leaf memory leaf;\\n        RLPReader.RLPItem[] memory decoded = node\\n            .data\\n            .data\\n            .toRlpItem()\\n            .toList();\\n        bytes memory data = decoded[1].toBytes();\\n        //Remove the first byte, which is the prefix and not present in the user provided key\\n        leaf.key = NibbleSlice(Bytes.substr(decoded[0].toBytes(), 1), 0);\\n        leaf.value = NodeHandle(false, bytes32(0), true, data);\\n\\n        return leaf;\\n    }', 'function mid(\\n        NibbleSlice memory self,\\n        uint256 i\\n    ) internal pure returns (NibbleSlice memory) {\\n        return NibbleSlice(self.data, self.offset + i);\\n    }', 'function isLeaf(NodeKind memory node) internal pure returns (bool) {\\n        return (node.isLeaf || node.isHashedLeaf);\\n    }'}"
                },
                {
                    "identifier": "VerifyEthereumProof",
                    "parameters": "bytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "modifiers": "pure",
                    "return": "returns (StorageValue[] memory)",
                    "body": "function VerifyEthereumProof(\n        bytes32 root,\n        bytes[] memory proof,\n        bytes[] memory keys\n    ) public pure returns (StorageValue[] memory) {\n        StorageValue[] memory values = new StorageValue[](keys.length);\n        TrieNode[] memory nodes = new TrieNode[](proof.length);\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            nodes[i] = TrieNode(keccak256(proof[i]), proof[i]);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            values[i].key = keys[i];\n            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);\n            NodeKind memory node = EthereumTrieDB.decodeNodeKind(\n                TrieDB.get(nodes, root)\n            );\n\n            // This loop is unbounded so that an adversary cannot insert a deeply nested key in the trie\n            // and successfully convince us of it's non-existence, if we consume the block gas limit while\n            // traversing the trie, then the transaction should revert.\n            for (uint256 j = 1; j > 0; j++) {\n                NodeHandle memory nextNode;\n\n                if (TrieDB.isLeaf(node)) {\n                    Leaf memory leaf = EthereumTrieDB.decodeLeaf(node);\n                    // Let's retrieve the offset to be used\n                    uint256 offset = keyNibbles.offset % 2 == 0\n                        ? keyNibbles.offset / 2\n                        : keyNibbles.offset / 2 + 1;\n                    // Let's cut the key passed as input\n                    keyNibbles = NibbleSlice(\n                        NibbleSliceOps.bytesSlice(keyNibbles.data, offset),\n                        0\n                    );\n                    if (NibbleSliceOps.eq(leaf.key, keyNibbles)) {\n                        values[i].value = TrieDB.load(nodes, leaf.value);\n                    }\n                    break;\n                } else if (TrieDB.isExtension(node)) {\n                    Extension memory extension = EthereumTrieDB.decodeExtension(\n                        node\n                    );\n                    if (NibbleSliceOps.startsWith(keyNibbles, extension.key)) {\n                        // Let's cut the key passed as input\n                        uint256 cutNibble = keyNibbles.offset +\n                            NibbleSliceOps.len(extension.key);\n                        keyNibbles = NibbleSlice(\n                            NibbleSliceOps.bytesSlice(\n                                keyNibbles.data,\n                                cutNibble / 2\n                            ),\n                            cutNibble % 2\n                        );\n                        nextNode = extension.node;\n                    } else {\n                        break;\n                    }\n                } else if (TrieDB.isBranch(node)) {\n                    Branch memory branch = EthereumTrieDB.decodeBranch(node);\n                    if (NibbleSliceOps.isEmpty(keyNibbles)) {\n                        if (Option.isSome(branch.value)) {\n                            values[i].value = TrieDB.load(\n                                nodes,\n                                branch.value.value\n                            );\n                        }\n                        break;\n                    } else {\n                        NodeHandleOption memory handle = branch.children[\n                            NibbleSliceOps.at(keyNibbles, 0)\n                        ];\n                        if (Option.isSome(handle)) {\n                            keyNibbles = NibbleSliceOps.mid(keyNibbles, 1);\n                            nextNode = handle.value;\n                        } else {\n                            break;\n                        }\n                    }\n                } else if (TrieDB.isEmpty(node)) {\n                    break;\n                }\n\n                node = EthereumTrieDB.decodeNodeKind(\n                    TrieDB.load(nodes, nextNode)\n                );\n            }\n        }\n\n        return values;\n    }",
                    "start": "145",
                    "end": "236",
                    "class": "MerklePatricia",
                    "signature": "returns (StorageValue[] memory) VerifyEthereumProofbytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "full_signature": "function VerifyEthereumProof(bytes32 root, bytes[] memory proof, bytes[] memory keys) public  pure returns (StorageValue[] memory)",
                    "class_method_signature": "MerklePatricia.VerifyEthereumProofbytes32 root, bytes[] memory proof, bytes[] memory keys",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "public",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"./trie/Node.sol\";",
                        "import \"./trie/Option.sol\";",
                        "import \"./trie/NibbleSlice.sol\";",
                        "import \"./trie/TrieDB.sol\";",
                        "import \"./trie/substrate/SubstrateTrieDB.sol\";",
                        "import \"./trie/ethereum/EthereumTrieDB.sol\";",
                        "import \"./Types.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Verifies Ethereum Merkle Patricia Trie proofs for given keys.\n * @dev Processes a proof to verify the existence of key-value pairs in the trie.\n *\n * @param root The root hash of the trie to verify against.\n * @param proof Array of proof elements (nodes) needed to verify the keys.\n * @param keys Array of keys to verify in the trie.\n * @return values Array of StorageValue structs containing the keys and their corresponding values if found.\n *\n * Steps:\n * 1. Initialize arrays for storage values and trie nodes.\n * 2. Process each proof element into TrieNode structs with their hashes.\n * 3. For each key:\n *    a) Initialize key nibbles for traversal.\n *    b) Decode the root node to begin traversal.\n *    c) Traverse the trie:\n *       - If node is a leaf:\n *         * Compare leaf key with remaining key nibbles.\n *         * If match, store the value.\n *       - If node is an extension:\n *         * Check if key starts with extension's prefix.\n *         * If match, move to next node and adjust key nibbles.\n *       - If node is a branch:\n *         * If no nibbles remain, check for branch value.\n *         * Otherwise follow the appropriate child node.\n *       - If node is empty or no match found, break.\n *    d) Continue traversal until value found or path exhausted.\n * 4. Return all found key-value pairs.\n *\n * Note: The traversal loop is unbounded to prevent adversaries from creating deep\n * nested keys that could exhaust gas before proving non-existence.\n */",
                    "tdd": "{\"function VerifyEthereumProof(\\n        bytes32 root,\\n        bytes[] memory proof,\\n        bytes[] memory keys\\n    ) public pure returns (StorageValue[] memory) {\\n        StorageValue[] memory values = new StorageValue[](keys.length);\\n        TrieNode[] memory nodes = new TrieNode[](proof.length);\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            nodes[i] = TrieNode(keccak256(proof[i]), proof[i]);\\n        }\\n\\n        for (uint256 i = 0; i < keys.length; i++) {\\n            values[i].key = keys[i];\\n            NibbleSlice memory keyNibbles = NibbleSlice(keys[i], 0);\\n            NodeKind memory node = EthereumTrieDB.decodeNodeKind(\\n                TrieDB.get(nodes, root)\\n            );\\n\\n            // This loop is unbounded so that an adversary cannot insert a deeply nested key in the trie\\n            // and successfully convince us of it's non-existence, if we consume the block gas limit while\\n            // traversing the trie, then the transaction should revert.\\n            for (uint256 j = 1; j > 0; j++) {\\n                NodeHandle memory nextNode;\\n\\n                if (TrieDB.isLeaf(node)) {\\n                    Leaf memory leaf = EthereumTrieDB.decodeLeaf(node);\\n                    // Let's retrieve the offset to be used\\n                    uint256 offset = keyNibbles.offset % 2 == 0\\n                        ? keyNibbles.offset / 2\\n                        : keyNibbles.offset / 2 + 1;\\n                    // Let's cut the key passed as input\\n                    keyNibbles = NibbleSlice(\\n                        NibbleSliceOps.bytesSlice(keyNibbles.data, offset),\\n                        0\\n                    );\\n                    if (NibbleSliceOps.eq(leaf.key, keyNibbles)) {\\n                        values[i].value = TrieDB.load(nodes, leaf.value);\\n                    }\\n                    break;\\n                } else if (TrieDB.isExtension(node)) {\\n                    Extension memory extension = EthereumTrieDB.decodeExtension(\\n                        node\\n                    );\\n                    if (NibbleSliceOps.startsWith(keyNibbles, extension.key)) {\\n                        // Let's cut the key passed as input\\n                        uint256 cutNibble = keyNibbles.offset +\\n                            NibbleSliceOps.len(extension.key);\\n                        keyNibbles = NibbleSlice(\\n                            NibbleSliceOps.bytesSlice(\\n                                keyNibbles.data,\\n                                cutNibble / 2\\n                            ),\\n                            cutNibble % 2\\n                        );\\n                        nextNode = extension.node;\\n                    } else {\\n                        break;\\n                    }\\n                } else if (TrieDB.isBranch(node)) {\\n                    Branch memory branch = EthereumTrieDB.decodeBranch(node);\\n                    if (NibbleSliceOps.isEmpty(keyNibbles)) {\\n                        if (Option.isSome(branch.value)) {\\n                            values[i].value = TrieDB.load(\\n                                nodes,\\n                                branch.value.value\\n                            );\\n                        }\\n                        break;\\n                    } else {\\n                        NodeHandleOption memory handle = branch.children[\\n                            NibbleSliceOps.at(keyNibbles, 0)\\n                        ];\\n                        if (Option.isSome(handle)) {\\n                            keyNibbles = NibbleSliceOps.mid(keyNibbles, 1);\\n                            nextNode = handle.value;\\n                        } else {\\n                            break;\\n                        }\\n                    }\\n                } else if (TrieDB.isEmpty(node)) {\\n                    break;\\n                }\\n\\n                node = EthereumTrieDB.decodeNodeKind(\\n                    TrieDB.load(nodes, nextNode)\\n                );\\n            }\\n        }\\n\\n        return values;\\n    }\"}",
                    "context": "{'function isEmpty(NibbleSlice memory self) internal pure returns (bool) {\\n        return len(self) == 0;\\n    }', 'function decodeBranch(\\n        NodeKind memory node\\n    ) external pure returns (Branch memory) {\\n        Branch memory branch;\\n        RLPReader.RLPItem[] memory decoded = node\\n            .data\\n            .data\\n            .toRlpItem()\\n            .toList();\\n\\n        NodeHandleOption[16] memory childrens;\\n\\n        for (uint256 i = 0; i < 16; i++) {\\n            bytes memory dataAsBytes = decoded[i].toBytes();\\n            if (dataAsBytes.length != 32) {\\n                childrens[i] = NodeHandleOption(\\n                    false,\\n                    NodeHandle(false, bytes32(0), false, new bytes(0))\\n                );\\n            } else {\\n                bytes32 data = Bytes.toBytes32(dataAsBytes);\\n                childrens[i] = NodeHandleOption(\\n                    true,\\n                    NodeHandle(true, data, false, new bytes(0))\\n                );\\n            }\\n        }\\n        if (isEmpty(decoded[16].toBytes())) {\\n            branch.value = NodeHandleOption(\\n                false,\\n                NodeHandle(false, bytes32(0), false, new bytes(0))\\n            );\\n        } else {\\n            branch.value = NodeHandleOption(\\n                true,\\n                NodeHandle(false, bytes32(0), true, decoded[16].toBytes())\\n            );\\n        }\\n        branch.children = childrens;\\n\\n        return branch;\\n    }', 'function isSome(NodeHandleOption memory val) internal pure returns (bool) {\\n        return val.isSome == true;\\n    }', 'function eq(\\n        NibbleSlice memory self,\\n        NibbleSlice memory other\\n    ) internal pure returns (bool) {\\n        return len(self) == len(other) && startsWith(self, other);\\n    }', 'function isEmpty(NodeKind memory node) internal pure returns (bool) {\\n        return node.isEmpty;\\n    }', 'function isSome(ValueOption memory val) internal pure returns (bool) {\\n        return val.isSome == true;\\n    }', 'function decodeNodeKind(\\n        bytes memory encoded\\n    ) internal pure returns (NodeKind memory) {\\n        NodeKind memory node;\\n        ByteSlice memory input = ByteSlice(encoded, 0);\\n        uint8 i = Bytes.readByte(input);\\n\\n        if (i == EMPTY_TRIE) {\\n            node.isEmpty = true;\\n            return node;\\n        }\\n\\n        uint8 mask = i & (0x03 << 6);\\n\\n        if (mask == LEAF_PREFIX_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isLeaf = true;\\n        } else if (mask == BRANCH_WITH_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isNibbledValueBranch = true;\\n        } else if (mask == BRANCH_WITHOUT_MASK) {\\n            node.nibbleSize = decodeSize(i, input, 2);\\n            node.isNibbledBranch = true;\\n        } else if (mask == EMPTY_TRIE) {\\n            if (i & (0x07 << 5) == ALT_HASHING_LEAF_PREFIX_MASK) {\\n                node.nibbleSize = decodeSize(i, input, 3);\\n                node.isHashedLeaf = true;\\n            } else if (i & (0x0F << 4) == ALT_HASHING_BRANCH_WITH_MASK) {\\n                node.nibbleSize = decodeSize(i, input, 4);\\n                node.isNibbledHashedValueBranch = true;\\n            } else {\\n                // do not allow any special encoding\\n                revert(\"Unallowed encoding\");\\n            }\\n        }\\n        node.data = input;\\n\\n        return node;\\n    }', 'function decodeNodeKind(\\n        bytes memory encoded\\n    ) external pure returns (NodeKind memory) {\\n        NodeKind memory node;\\n        ByteSlice memory input = ByteSlice(encoded, 0);\\n        if (Bytes.equals(encoded, HASHED_NULL_NODE)) {\\n            node.isEmpty = true;\\n            return node;\\n        }\\n        RLPReader.RLPItem[] memory itemList = encoded.toRlpItem().toList();\\n        uint256 numItems = itemList.length;\\n        if (numItems == 0) {\\n            node.isEmpty = true;\\n            return node;\\n        } else if (numItems == 2) {\\n            //It may be a leaf or extension\\n            bytes memory key = itemList[0].toBytes();\\n            uint256 prefix;\\n            assembly {\\n                let first := shr(248, mload(add(key, 32)))\\n                prefix := shr(4, first)\\n            }\\n            if (prefix == 2 || prefix == 3) {\\n                node.isLeaf = true;\\n            } else {\\n                node.isExtension = true;\\n            }\\n        } else if (numItems == 17) {\\n            node.isBranch = true;\\n        } else {\\n            revert(\"Invalid data\");\\n        }\\n        node.data = input;\\n        return node;\\n    }', 'function decodeLeaf(\\n        NodeKind memory node\\n    ) internal pure returns (Leaf memory) {\\n        Leaf memory leaf;\\n        ByteSlice memory input = node.data;\\n\\n        bool padding = node.nibbleSize % NIBBLE_PER_BYTE != 0;\\n        if (padding && padLeft(uint8(input.data[input.offset])) != 0) {\\n            revert(\"Bad Format!\");\\n        }\\n        uint256 nibbleLen = (node.nibbleSize +\\n            (NibbleSliceOps.NIBBLE_PER_BYTE - 1)) /\\n            NibbleSliceOps.NIBBLE_PER_BYTE;\\n        bytes memory nibbleBytes = Bytes.read(input, nibbleLen);\\n        leaf.key = NibbleSlice(nibbleBytes, node.nibbleSize % NIBBLE_PER_BYTE);\\n\\n        NodeHandle memory handle;\\n        if (node.isHashedLeaf) {\\n            handle.isHash = true;\\n            handle.hash = Bytes.toBytes32(Bytes.read(input, HASH_lENGTH));\\n        } else {\\n            uint256 len = ScaleCodec.decodeUintCompact(input);\\n            handle.isInline = true;\\n            handle.inLine = Bytes.read(input, len);\\n        }\\n        leaf.value = handle;\\n\\n        return leaf;\\n    }', 'function len(NibbleSlice memory nibble) internal pure returns (uint256) {\\n        return nibble.data.length * NIBBLE_PER_BYTE - nibble.offset;\\n    }', 'function startsWith(\\n        NibbleSlice memory self,\\n        NibbleSlice memory other\\n    ) internal pure returns (bool) {\\n        return commonPrefix(self, other) == len(other);\\n    }', 'function load(\\n        TrieNode[] memory nodes,\\n        NodeHandle memory node\\n    ) internal pure returns (bytes memory) {\\n        if (node.isInline) {\\n            return node.inLine;\\n        } else if (node.isHash) {\\n            return get(nodes, node.hash);\\n        }\\n\\n        return bytes(\"\");\\n    }', 'function isExtension(NodeKind memory node) internal pure returns (bool) {\\n        return node.isExtension;\\n    }', 'function get(\\n        TrieNode[] memory nodes,\\n        bytes32 hash\\n    ) internal pure returns (bytes memory) {\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            if (nodes[i].hash == hash) {\\n                return nodes[i].node;\\n            }\\n        }\\n        revert(\"Incomplete Proof!\");\\n    }', 'function isBranch(NodeKind memory node) internal pure returns (bool) {\\n        return node.isBranch;\\n    }', 'function at(\\n        NibbleSlice memory self,\\n        uint256 i\\n    ) internal pure returns (uint256) {\\n        uint256 ix = (self.offset + i) / NIBBLE_PER_BYTE;\\n        uint256 pad = (self.offset + i) % NIBBLE_PER_BYTE;\\n        uint8 data = uint8(self.data[ix]);\\n        return (pad == 1) ? data & 0x0F : data >> BITS_PER_NIBBLE;\\n    }', 'function isEmpty(bytes memory item) internal pure returns (bool) {\\n        return item.length > 0 && (item[0] == 0xc0 || item[0] == 0x80);\\n    }', 'function bytesSlice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    ) internal pure returns (bytes memory) {\\n        uint256 bytesLength = _bytes.length;\\n        uint256 _length = bytesLength - _start;\\n        require(bytesLength >= _start, \"slice_outOfBounds\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                tempBytes := mload(0x40) // load free memory pointer\\n                let lengthmod := and(_length, 31)\\n\\n                let mc := add(\\n                    add(tempBytes, lengthmod),\\n                    mul(0x20, iszero(lengthmod))\\n                )\\n                let end := add(mc, _length)\\n\\n                for {\\n                    let cc := add(\\n                        add(\\n                            add(_bytes, lengthmod),\\n                            mul(0x20, iszero(lengthmod))\\n                        ),\\n                        _start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            default {\\n                tempBytes := mload(0x40)\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n        return tempBytes;\\n    }', 'function decodeExtension(\\n        NodeKind memory node\\n    ) external pure returns (Extension memory) {\\n        Extension memory extension;\\n        RLPReader.RLPItem[] memory decoded = node\\n            .data\\n            .data\\n            .toRlpItem()\\n            .toList();\\n        bytes memory data = decoded[1].toBytes();\\n        uint8 isOdd = uint8(decoded[0].toBytes()[0] >> 4) & 0x01;\\n        //Remove the first byte, which is the prefix and not present in the user provided key\\n        extension.key = NibbleSlice(\\n            Bytes.substr(decoded[0].toBytes(), (isOdd + 1) % 2),\\n            isOdd\\n        );\\n        extension.node = NodeHandle(\\n            true,\\n            Bytes.toBytes32(data),\\n            false,\\n            new bytes(0)\\n        );\\n        return extension;\\n    }', 'function decodeLeaf(\\n        NodeKind memory node\\n    ) external pure returns (Leaf memory) {\\n        Leaf memory leaf;\\n        RLPReader.RLPItem[] memory decoded = node\\n            .data\\n            .data\\n            .toRlpItem()\\n            .toList();\\n        bytes memory data = decoded[1].toBytes();\\n        //Remove the first byte, which is the prefix and not present in the user provided key\\n        leaf.key = NibbleSlice(Bytes.substr(decoded[0].toBytes(), 1), 0);\\n        leaf.value = NodeHandle(false, bytes32(0), true, data);\\n\\n        return leaf;\\n    }', 'function mid(\\n        NibbleSlice memory self,\\n        uint256 i\\n    ) internal pure returns (NibbleSlice memory) {\\n        return NibbleSlice(self.data, self.offset + i);\\n    }', 'function isLeaf(NodeKind memory node) internal pure returns (bool) {\\n        return (node.isLeaf || node.isHashedLeaf);\\n    }'}"
                }
            ]
        }
    ],
    "repository/solidity-merkle-trees/src/MerkleMultiProof.sol": [
        {
            "methods": [
                {
                    "identifier": "CalculateRoot",
                    "parameters": "Node[][] memory proof, Node[] memory leaves",
                    "modifiers": "pure",
                    "return": "returns (bytes32)",
                    "body": "function CalculateRoot(\n        Node[][] memory proof,\n        Node[] memory leaves\n    ) internal pure returns (bytes32) {\n        // holds the output from hashing a previous layer\n        Node[] memory next_layer = new Node[](0);\n\n        // merge leaves\n        proof[0] = mergeSort(leaves, proof[0]);\n\n        uint256 proof_length = proof.length;\n        for (uint256 height = 0; height < proof_length; height++) {\n            Node[] memory current_layer = new Node[](0);\n\n            if (next_layer.length == 0) {\n                current_layer = proof[height];\n            } else {\n                current_layer = mergeSort(proof[height], next_layer);\n            }\n\n            next_layer = new Node[](div_ceil(current_layer.length, 2));\n\n            uint256 p = 0;\n            uint256 current_layer_length = current_layer.length;\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\n                if (index + 1 >= current_layer_length) {\n                    Node memory node = current_layer[index];\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\n                    next_layer[p] = node;\n                } else {\n                    Node memory node;\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\n                    node.node = _optimizedHash(\n                        current_layer[index].node,\n                        current_layer[index + 1].node\n                    );\n                    next_layer[p] = node;\n                    unchecked {\n                        p++;\n                    }\n                }\n            }\n        }\n\n        // we should have arrived at the root node\n        require(next_layer.length == 1);\n\n        return next_layer[0].node;\n    }",
                    "start": "49",
                    "end": "97",
                    "class": "MerkleMultiProof",
                    "signature": "returns (bytes32) CalculateRootNode[][] memory proof, Node[] memory leaves",
                    "full_signature": "function CalculateRoot(Node[][] memory proof, Node[] memory leaves) internal pure returns (bytes32)",
                    "class_method_signature": "MerkleMultiProof.CalculateRootNode[][] memory proof, Node[] memory leaves",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Calculates the Merkle root from given proof and leaves.\n * @dev Uses a multi-layer hashing approach to compute the root.\n *\n * Steps:\n * 1. Initialize an empty array for the next layer of nodes.\n * 2. Merge the input leaves with the first layer of the proof using mergeSort.\n *\n * 3. Iterate through each height of the proof:\n *    a. Initialize current_layer array.\n *    b. If next_layer is empty, use current proof layer.\n *    c. Otherwise, merge current proof layer with next_layer.\n *\n * 4. Prepare next_layer with half the size of current_layer (rounded up).\n * 5. Process current_layer in pairs:\n *    a. For odd-length layers, carry forward the last node.\n *    b. For pairs, hash them together and store in next_layer.\n *    c. Update node indices accordingly.\n *\n * 6. After processing all layers, verify we have exactly one node left (the root).\n * 7. Return the computed root node.\n *\n * @param proof Array of proof layers containing nodes.\n * @param leaves Array of leaf nodes to start computation.\n * @return bytes32 The computed Merkle root.\n */",
                    "tdd": "{'function CalculateRoot(\\n        Node[][] memory proof,\\n        Node[] memory leaves\\n    ) internal pure returns (bytes32) {\\n        // holds the output from hashing a previous layer\\n        Node[] memory next_layer = new Node[](0);\\n\\n        // merge leaves\\n        proof[0] = mergeSort(leaves, proof[0]);\\n\\n        uint256 proof_length = proof.length;\\n        for (uint256 height = 0; height < proof_length; height++) {\\n            Node[] memory current_layer = new Node[](0);\\n\\n            if (next_layer.length == 0) {\\n                current_layer = proof[height];\\n            } else {\\n                current_layer = mergeSort(proof[height], next_layer);\\n            }\\n\\n            next_layer = new Node[](div_ceil(current_layer.length, 2));\\n\\n            uint256 p = 0;\\n            uint256 current_layer_length = current_layer.length;\\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\\n                if (index + 1 >= current_layer_length) {\\n                    Node memory node = current_layer[index];\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    next_layer[p] = node;\\n                } else {\\n                    Node memory node;\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    node.node = _optimizedHash(\\n                        current_layer[index].node,\\n                        current_layer[index + 1].node\\n                    );\\n                    next_layer[p] = node;\\n                    unchecked {\\n                        p++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // we should have arrived at the root node\\n        require(next_layer.length == 1);\\n\\n        return next_layer[0].node;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "CalculateRootSorted",
                    "parameters": "Node[][] memory proof, Node[] memory leaves",
                    "modifiers": "pure",
                    "return": "returns (bytes32)",
                    "body": "function CalculateRootSorted(\n        Node[][] memory proof,\n        Node[] memory leaves\n    ) internal pure returns (bytes32) {\n        // holds the output from hashing a previous layer\n        Node[] memory next_layer = new Node[](0);\n\n        // merge leaves\n        proof[0] = mergeSort(leaves, proof[0]);\n\n        uint256 proof_length = proof.length;\n        for (uint256 height = 0; height < proof_length; height++) {\n            Node[] memory current_layer = new Node[](0);\n\n            if (next_layer.length == 0) {\n                current_layer = proof[height];\n            } else {\n                current_layer = mergeSort(proof[height], next_layer);\n            }\n            uint256 current_layer_length = current_layer.length;\n            uint256 p = 0;\n\n            next_layer = new Node[](div_ceil(current_layer_length, 2));\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\n                if (index + 1 >= current_layer_length) {\n                    Node memory node = current_layer[index];\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\n                    next_layer[p] = node;\n                } else {\n                    Node memory node;\n                    bytes32 a = current_layer[index].node;\n                    bytes32 b = current_layer[index + 1].node;\n                    if (a < b) {\n                        node.node = _optimizedHash(a, b);\n                    } else {\n                        node.node = _optimizedHash(b, a);\n                    }\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\n                    next_layer[p] = node;\n                    unchecked {\n                        p++;\n                    }\n                }\n            }\n        }\n\n        // we should have arrived at the root node\n        require(next_layer.length == 1);\n\n        return next_layer[0].node;\n    }",
                    "start": "104",
                    "end": "154",
                    "class": "MerkleMultiProof",
                    "signature": "returns (bytes32) CalculateRootSortedNode[][] memory proof, Node[] memory leaves",
                    "full_signature": "function CalculateRootSorted(Node[][] memory proof, Node[] memory leaves) internal pure returns (bytes32)",
                    "class_method_signature": "MerkleMultiProof.CalculateRootSortedNode[][] memory proof, Node[] memory leaves",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Calculates the Merkle root from sorted nodes and proof layers.\n * @dev Processes the proof layers and leaves to compute the Merkle root hash.\n *\n * Steps:\n * 1. Initialize an empty array `next_layer` to store intermediate hashing results.\n * 2. Merge and sort the input leaves with the first proof layer.\n *\n * 3. Iterate through each proof layer:\n *    a. If `next_layer` is empty, use the current proof layer as `current_layer`.\n *    b. Otherwise, merge and sort the current proof layer with `next_layer`.\n *\n * 4. Process `current_layer` to compute the next layer:\n *    a. Initialize `next_layer` with half the size (rounded up) of `current_layer`.\n *    b. For each pair of nodes in `current_layer`:\n *       i. If there's only one node left, carry it forward with updated index.\n *       ii. For pairs, hash them in sorted order and store the result with updated index.\n *\n * 5. After processing all layers, verify that only the root node remains in `next_layer`.\n * 6. Return the computed root node hash.\n *\n * @param proof Array of proof layers containing sorted nodes.\n * @param leaves Array of leaf nodes to start the computation.\n * @return bytes32 The computed Merkle root hash.\n */",
                    "tdd": "{'function CalculateRootSorted(\\n        Node[][] memory proof,\\n        Node[] memory leaves\\n    ) internal pure returns (bytes32) {\\n        // holds the output from hashing a previous layer\\n        Node[] memory next_layer = new Node[](0);\\n\\n        // merge leaves\\n        proof[0] = mergeSort(leaves, proof[0]);\\n\\n        uint256 proof_length = proof.length;\\n        for (uint256 height = 0; height < proof_length; height++) {\\n            Node[] memory current_layer = new Node[](0);\\n\\n            if (next_layer.length == 0) {\\n                current_layer = proof[height];\\n            } else {\\n                current_layer = mergeSort(proof[height], next_layer);\\n            }\\n            uint256 current_layer_length = current_layer.length;\\n            uint256 p = 0;\\n\\n            next_layer = new Node[](div_ceil(current_layer_length, 2));\\n            for (uint256 index = 0; index < current_layer_length; index += 2) {\\n                if (index + 1 >= current_layer_length) {\\n                    Node memory node = current_layer[index];\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    next_layer[p] = node;\\n                } else {\\n                    Node memory node;\\n                    bytes32 a = current_layer[index].node;\\n                    bytes32 b = current_layer[index + 1].node;\\n                    if (a < b) {\\n                        node.node = _optimizedHash(a, b);\\n                    } else {\\n                        node.node = _optimizedHash(b, a);\\n                    }\\n                    node.k_index = div_floor(current_layer[index].k_index, 2);\\n                    next_layer[p] = node;\\n                    unchecked {\\n                        p++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // we should have arrived at the root node\\n        require(next_layer.length == 1);\\n\\n        return next_layer[0].node;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "TreeHeight",
                    "parameters": "uint256 leavesCount",
                    "modifiers": "pure",
                    "return": "returns (uint256)",
                    "body": "function TreeHeight(uint256 leavesCount) internal pure returns (uint256) {\n        uint256 height = Math.log2(leavesCount, Math.Rounding.Up);\n        if (!isPowerOfTwo(leavesCount)) {\n            unchecked {\n                height++;\n            }\n        }\n\n        return height;\n    }",
                    "start": "241",
                    "end": "250",
                    "class": "MerkleMultiProof",
                    "signature": "returns (uint256) TreeHeightuint256 leavesCount",
                    "full_signature": "function TreeHeight(uint256 leavesCount) internal pure returns (uint256)",
                    "class_method_signature": "MerkleMultiProof.TreeHeightuint256 leavesCount",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.17;"
                    ],
                    "import_directive": [
                        "import \"@openzeppelin/contracts/utils/math/Math.sol\";",
                        "import \"./Types.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Calculates the height of a merkle tree given the number of leaves.\n * @dev Uses log2 calculation with rounding up to determine initial height.\n *       If the leaf count is not a power of two, increments the height by 1.\n * @param leavesCount The number of leaves in the merkle tree.\n * @return height The calculated height of the merkle tree.\n */",
                    "tdd": "{'function TreeHeight(uint256 leavesCount) internal pure returns (uint256) {\\n        uint256 height = Math.log2(leavesCount, Math.Rounding.Up);\\n        if (!isPowerOfTwo(leavesCount)) {\\n            unchecked {\\n                height++;\\n            }\\n        }\\n\\n        return height;\\n    }'}",
                    "context": "{'function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        uint256 exp;\\n        unchecked {\\n            exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);\\n            value >>= exp;\\n            result += exp;\\n\\n            result += SafeCast.toUint(value > 1);\\n        }\\n        return result;\\n    }', 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\\n        }\\n    }', 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }', 'function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }'}"
                }
            ]
        }
    ],
    "repository/BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol": [
        {
            "methods": [
                {
                    "identifier": "_daysFromDate",
                    "parameters": "uint year, uint month, uint day",
                    "modifiers": "pure",
                    "return": "returns (uint _days)",
                    "body": "function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }",
                    "start": "57",
                    "end": "71",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _days) _daysFromDateuint year, uint month, uint day",
                    "full_signature": "function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary._daysFromDateuint year, uint month, uint day",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the number of days elapsed since January 1, 1970 (Unix epoch) for a given date.\n * @dev Uses a mathematical formula to convert a Gregorian calendar date to Julian days.\n * \n * Steps:\n * 1. Validates that the year is 1970 or later.\n * 2. Converts input parameters to signed integers for calculations.\n * 3. Applies the Julian day calculation formula:\n *    - Adjusts for the 32075-day offset\n *    - Calculates leap years and month adjustments\n *    - Accounts for Gregorian calendar reform\n *    - Subtracts the Unix epoch offset (719162 days)\n * 4. Converts the result back to an unsigned integer.\n * \n * @param year The year (must be >= 1970)\n * @param month The month (1-12)\n * @param day The day of month (1-31)\n * @return _days Number of days since January 1, 1970\n */",
                    "tdd": "{'function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\\n        require(year >= 1970);\\n        int _year = int(year);\\n        int _month = int(month);\\n        int _day = int(day);\\n\\n        int __days = _day\\n          - 32075\\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\\n          - OFFSET19700101;\\n\\n        _days = uint(__days);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "_daysToDate",
                    "parameters": "uint _days",
                    "modifiers": "pure",
                    "return": "returns (uint year, uint month, uint day)",
                    "body": "function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }",
                    "start": "90",
                    "end": "107",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint year, uint month, uint day) _daysToDateuint _days",
                    "full_signature": "function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary._daysToDateuint _days",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Converts a number of days since 1970-01-01 into a date (year, month, day).\n * @dev Uses a mathematical algorithm to convert days to Gregorian calendar date.\n * \n * Steps:\n * 1. Adjust input days with offset constant (OFFSET19700101).\n * 2. Calculate intermediate values (L, N) for date conversion.\n * 3. Compute year, month, and day components through series of calculations.\n * 4. Adjust month and year values for proper calendar representation.\n * 5. Return the converted date components as unsigned integers.\n * \n * @param _days Number of days since 1970-01-01\n * @return year The calculated year\n * @return month The calculated month (1-12)\n * @return day The calculated day (1-31)\n */",
                    "tdd": "{'function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\\n        int __days = int(_days);\\n\\n        int L = __days + 68569 + OFFSET19700101;\\n        int N = 4 * L / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int _year = 4000 * (L + 1) / 1461001;\\n        L = L - 1461 * _year / 4 + 31;\\n        int _month = 80 * L / 2447;\\n        int _day = L - 2447 * _month / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint(_year);\\n        month = uint(_month);\\n        day = uint(_day);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "timestampToDateTime",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (uint year, uint month, uint day, uint hour, uint minute, uint second)",
                    "body": "function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }",
                    "start": "118",
                    "end": "125",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint year, uint month, uint day, uint hour, uint minute, uint second) timestampToDateTimeuint timestamp",
                    "full_signature": "function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.timestampToDateTimeuint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Converts a Unix timestamp to human-readable date and time components.\n * @dev Internal pure function that breaks down timestamp into year, month, day, hour, minute, and second.\n * \n * Steps:\n * 1. Converts timestamp to days and calls _daysToDate to get year, month, and day.\n * 2. Calculates remaining seconds in the day.\n * 3. Breaks down remaining seconds into hours, minutes, and seconds.\n * \n * @param timestamp The Unix timestamp to convert.\n * @return year The year component.\n * @return month The month component.\n * @return day The day component.\n * @return hour The hour component.\n * @return minute The minute component.\n * @return second The second component.\n */",
                    "tdd": "{'function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "isValidDate",
                    "parameters": "uint year, uint month, uint day",
                    "modifiers": "pure",
                    "return": "returns (bool valid)",
                    "body": "function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }",
                    "start": "127",
                    "end": "134",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (bool valid) isValidDateuint year, uint month, uint day",
                    "full_signature": "function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.isValidDateuint year, uint month, uint day",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Checks if a given date is valid.\n * @dev Validates that the year is 1970 or later, month is between 1-12,\n *      and day is within the valid range for the given month and year.\n * @param year The year to check.\n * @param month The month to check (1-12).\n * @param day The day to check.\n * @return valid Returns true if the date is valid, false otherwise.\n */",
                    "tdd": "{'function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "isValidDateTime",
                    "parameters": "uint year, uint month, uint day, uint hour, uint minute, uint second",
                    "modifiers": "pure",
                    "return": "returns (bool valid)",
                    "body": "function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }",
                    "start": "135",
                    "end": "141",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (bool valid) isValidDateTimeuint year, uint month, uint day, uint hour, uint minute, uint second",
                    "full_signature": "function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.isValidDateTimeuint year, uint month, uint day, uint hour, uint minute, uint second",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Checks if the given date and time components form a valid datetime.\n * @param year The year component.\n * @param month The month component (1-12).\n * @param day The day component (1-31, depending on month).\n * @param hour The hour component (0-23).\n * @param minute The minute component (0-59).\n * @param second The second component (0-59).\n * @return valid Returns true if all components form a valid datetime, false otherwise.\n *\n * Steps:\n * 1. First checks if the date components (year, month, day) are valid using isValidDate.\n * 2. If the date is valid, checks if the time components (hour, minute, second) are within valid ranges.\n * 3. Returns true only if both date and time components are valid.\n */",
                    "tdd": "{'function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "isLeapYear",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (bool leapYear)",
                    "body": "function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }",
                    "start": "142",
                    "end": "145",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (bool leapYear) isLeapYearuint timestamp",
                    "full_signature": "function isLeapYear(uint timestamp) internal pure returns (bool leapYear)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.isLeapYearuint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Checks if a given timestamp falls in a leap year.\n *\n * Steps:\n * 1. Convert the timestamp to days and extract the year component.\n * 2. Check if the extracted year is a leap year using the internal helper.\n * 3. Return the leap year status (true/false).\n *\n * @param timestamp The Unix timestamp to check.\n * @return leapYear Boolean indicating whether the year is a leap year.\n */",
                    "tdd": "{'function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "getDaysInMonth",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (uint daysInMonth)",
                    "body": "function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }",
                    "start": "155",
                    "end": "158",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint daysInMonth) getDaysInMonthuint timestamp",
                    "full_signature": "function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.getDaysInMonthuint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the number of days in a month for a given timestamp.\n *\n * Steps:\n * 1. Convert the timestamp to year, month, and day components using _daysToDate.\n * 2. Calculate the number of days in the month using _getDaysInMonth.\n * 3. Return the daysInMonth result.\n *\n * @param timestamp The Unix timestamp for which to calculate days in the month.\n * @return daysInMonth The number of days in the month for the given timestamp.\n */",
                    "tdd": "{'function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "_getDaysInMonth",
                    "parameters": "uint year, uint month",
                    "modifiers": "pure",
                    "return": "returns (uint daysInMonth)",
                    "body": "function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }",
                    "start": "159",
                    "end": "167",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint daysInMonth) _getDaysInMonthuint year, uint month",
                    "full_signature": "function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary._getDaysInMonthuint year, uint month",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the number of days in a given month of a year.\n * @dev Handles leap years for February calculation.\n *\n * @param year The year to check for leap year calculation (only affects February).\n * @param month The month (1-12) to get days for.\n * @return daysInMonth The number of days in the specified month.\n *\n * Logic:\n * 1. Returns 31 days for months January, March, May, July, August, October, December.\n * 2. Returns 30 days for months April, June, September, November.\n * 3. For February:\n *    - Checks if the year is a leap year using _isLeapYear()\n *    - Returns 29 days if leap year, 28 days otherwise.\n */",
                    "tdd": "{'function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "getDayOfWeek",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (uint dayOfWeek)",
                    "body": "function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }",
                    "start": "169",
                    "end": "172",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint dayOfWeek) getDayOfWeekuint timestamp",
                    "full_signature": "function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.getDayOfWeekuint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the day of the week from a given timestamp.\n * @dev Uses modulo arithmetic to determine the day (1-7) where 1 is Monday.\n * @param timestamp The Unix timestamp to convert to day of week.\n * @return dayOfWeek The day of week (1-7) where 1 is Monday.\n */",
                    "tdd": "{'function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\\n        uint _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = (_days + 3) % 7 + 1;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "getHour",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (uint hour)",
                    "body": "function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }",
                    "start": "183",
                    "end": "186",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint hour) getHouruint timestamp",
                    "full_signature": "function getHour(uint timestamp) internal pure returns (uint hour)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.getHouruint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Converts a timestamp to the corresponding hour of the day.\n * @param timestamp The Unix timestamp to convert.\n * @return hour The hour of the day (0-23) derived from the timestamp.\n * \n * Steps:\n * 1. Calculate the remaining seconds in the current day by taking the timestamp modulo SECONDS_PER_DAY.\n * 2. Convert the remaining seconds to hours by dividing by SECONDS_PER_HOUR.\n */",
                    "tdd": "{'function getHour(uint timestamp) internal pure returns (uint hour) {\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "getMinute",
                    "parameters": "uint timestamp",
                    "modifiers": "pure",
                    "return": "returns (uint minute)",
                    "body": "function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }",
                    "start": "187",
                    "end": "190",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint minute) getMinuteuint timestamp",
                    "full_signature": "function getMinute(uint timestamp) internal pure returns (uint minute)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.getMinuteuint timestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Gets the minute component from a given timestamp.\n * @dev Internal pure function that calculates minutes from seconds.\n * @param timestamp The Unix timestamp to extract minutes from.\n * @return minute The minute component (0-59) of the given timestamp.\n * \n * Steps:\n * 1. Calculate remaining seconds after removing full hours.\n * 2. Convert remaining seconds to minutes by dividing by SECONDS_PER_MINUTE.\n */",
                    "tdd": "{'function getMinute(uint timestamp) internal pure returns (uint minute) {\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addYears",
                    "parameters": "uint timestamp, uint _years",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "195",
                    "end": "204",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addYearsuint timestamp, uint _years",
                    "full_signature": "function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addYearsuint timestamp, uint _years",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds a specified number of years to a given timestamp while handling leap years and month boundaries.\n * @dev Adjusts for cases where the original day doesn't exist in the new month (e.g., Feb 29 -> Feb 28 in non-leap years).\n * \n * Steps:\n * 1. Convert the timestamp to year, month, and day components.\n * 2. Add the specified number of years to the year component.\n * 3. Get the number of days in the resulting month.\n * 4. If the original day exceeds the days in the new month, set day to maximum days in that month.\n * 5. Convert the adjusted date back to a timestamp.\n * 6. Ensure the new timestamp is not earlier than the original timestamp.\n * \n * @param timestamp The original timestamp to add years to.\n * @param _years The number of years to add.\n * @return newTimestamp The resulting timestamp after adding the years.\n */",
                    "tdd": "{'function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year += _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addMonths",
                    "parameters": "uint timestamp, uint _months",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "205",
                    "end": "216",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addMonthsuint timestamp, uint _months",
                    "full_signature": "function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addMonthsuint timestamp, uint _months",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds a specified number of months to a given timestamp.\n * @dev Handles month overflow by incrementing years and adjusts days for months with fewer days.\n * \n * Steps:\n * 1. Convert timestamp to year, month, and day components.\n * 2. Add the specified months to the current month.\n * 3. Adjust year and month if month addition causes overflow (beyond 12 months).\n * 4. Get the number of days in the resulting month.\n * 5. Adjust day if it exceeds the days in the resulting month.\n * 6. Convert the adjusted date components back to a timestamp.\n * 7. Ensure the new timestamp is not earlier than the original timestamp.\n * \n * @param timestamp The original timestamp to add months to.\n * @param _months The number of months to add.\n * @return newTimestamp The resulting timestamp after adding months.\n */",
                    "tdd": "{'function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = (month - 1) % 12 + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addDays",
                    "parameters": "uint timestamp, uint _days",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "217",
                    "end": "220",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addDaysuint timestamp, uint _days",
                    "full_signature": "function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addDaysuint timestamp, uint _days",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds a specified number of days to a given timestamp.\n * @dev Internal pure function that performs the calculation and checks for overflow.\n * @param timestamp The starting timestamp to which days will be added.\n * @param _days The number of days to add to the timestamp.\n * @return newTimestamp The resulting timestamp after adding the days.\n * \n * Steps:\n * 1. Calculate new timestamp by adding (days * seconds per day) to original timestamp.\n * 2. Check for overflow by ensuring new timestamp is greater than or equal to original.\n * 3. Return the new timestamp.\n */",
                    "tdd": "{'function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addHours",
                    "parameters": "uint timestamp, uint _hours",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "221",
                    "end": "224",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addHoursuint timestamp, uint _hours",
                    "full_signature": "function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addHoursuint timestamp, uint _hours",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds specified hours to a given timestamp and returns the new timestamp.\n * @dev Internal pure function that performs timestamp arithmetic with overflow check.\n * \n * @param timestamp The base timestamp to add hours to.\n * @param _hours The number of hours to add to the timestamp.\n * @return newTimestamp The resulting timestamp after adding the hours.\n * \n * Requirements:\n * - The resulting timestamp must be greater than or equal to the original timestamp\n *   (overflow protection).\n */",
                    "tdd": "{'function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addMinutes",
                    "parameters": "uint timestamp, uint _minutes",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "225",
                    "end": "228",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addMinutesuint timestamp, uint _minutes",
                    "full_signature": "function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addMinutesuint timestamp, uint _minutes",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds minutes to a given timestamp and returns the new timestamp.\n * @dev Ensures the new timestamp is not earlier than the original (preventing underflow).\n * @param timestamp The original timestamp to add minutes to.\n * @param _minutes The number of minutes to add.\n * @return newTimestamp The resulting timestamp after adding the minutes.\n */",
                    "tdd": "{'function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "addSeconds",
                    "parameters": "uint timestamp, uint _seconds",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }",
                    "start": "229",
                    "end": "232",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) addSecondsuint timestamp, uint _seconds",
                    "full_signature": "function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.addSecondsuint timestamp, uint _seconds",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Adds seconds to a given timestamp and returns the new timestamp.\n * @dev Ensures the new timestamp is not smaller than the original (preventing underflow).\n * @param timestamp The original timestamp to add seconds to.\n * @param _seconds The number of seconds to add.\n * @return newTimestamp The resulting timestamp after adding the seconds.\n */",
                    "tdd": "{'function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subYears",
                    "parameters": "uint timestamp, uint _years",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "234",
                    "end": "243",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subYearsuint timestamp, uint _years",
                    "full_signature": "function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subYearsuint timestamp, uint _years",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts years from a given timestamp.\n * @dev Handles leap years and month/day adjustments.\n * \n * Steps:\n * 1. Converts the timestamp to year, month, and day components.\n * 2. Subtracts the specified number of years from the year component.\n * 3. Gets the number of days in the adjusted month/year.\n * 4. Adjusts the day if it exceeds the days in the new month.\n * 5. Converts the adjusted date back to a timestamp.\n * 6. Ensures the new timestamp is not greater than the original.\n * \n * @param timestamp The original timestamp to subtract from.\n * @param _years The number of years to subtract.\n * @return newTimestamp The resulting timestamp after subtraction.\n */",
                    "tdd": "{'function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year -= _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subMonths",
                    "parameters": "uint timestamp, uint _months",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "244",
                    "end": "255",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subMonthsuint timestamp, uint _months",
                    "full_signature": "function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subMonthsuint timestamp, uint _months",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts a specified number of months from a given timestamp.\n * @dev Handles month and year overflow/underflow and adjusts days accordingly.\n * \n * Steps:\n * 1. Converts the timestamp to year, month, and day components.\n * 2. Calculates the new year and month by subtracting the specified months.\n * 3. Adjusts the day if it exceeds the days in the new month.\n * 4. Converts the adjusted date back to a timestamp.\n * 5. Ensures the resulting timestamp is not greater than the original.\n * \n * @param timestamp The original timestamp to subtract from.\n * @param _months The number of months to subtract.\n * @return newTimestamp The resulting timestamp after subtraction.\n */",
                    "tdd": "{'function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = yearMonth % 12 + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subDays",
                    "parameters": "uint timestamp, uint _days",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "256",
                    "end": "259",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subDaysuint timestamp, uint _days",
                    "full_signature": "function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subDaysuint timestamp, uint _days",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts a specified number of days from a given timestamp.\n * @dev Internal pure function that performs the calculation and validates the result.\n * \n * @param timestamp The original timestamp to subtract from.\n * @param _days The number of days to subtract.\n * \n * @return newTimestamp The resulting timestamp after subtraction.\n * \n * Requirements:\n * - The resulting timestamp must be less than or equal to the original timestamp.\n */",
                    "tdd": "{'function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subHours",
                    "parameters": "uint timestamp, uint _hours",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "260",
                    "end": "263",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subHoursuint timestamp, uint _hours",
                    "full_signature": "function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subHoursuint timestamp, uint _hours",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts hours from a given timestamp.\n * @param timestamp The original timestamp to subtract from.\n * @param _hours The number of hours to subtract.\n * @return newTimestamp The resulting timestamp after subtraction.\n * @dev Reverts if the subtraction would result in an underflow (newTimestamp > timestamp).\n */",
                    "tdd": "{'function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subMinutes",
                    "parameters": "uint timestamp, uint _minutes",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "264",
                    "end": "267",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subMinutesuint timestamp, uint _minutes",
                    "full_signature": "function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subMinutesuint timestamp, uint _minutes",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts minutes from a given timestamp and returns the new timestamp.\n * @dev Internal pure function that performs the calculation and checks for underflow.\n * \n * @param timestamp The original timestamp to subtract from.\n * @param _minutes The number of minutes to subtract.\n * @return newTimestamp The resulting timestamp after subtraction.\n * \n * Requirements:\n * - The resulting timestamp must not be greater than the original timestamp (underflow check).\n */",
                    "tdd": "{'function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "subSeconds",
                    "parameters": "uint timestamp, uint _seconds",
                    "modifiers": "pure",
                    "return": "returns (uint newTimestamp)",
                    "body": "function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }",
                    "start": "268",
                    "end": "271",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint newTimestamp) subSecondsuint timestamp, uint _seconds",
                    "full_signature": "function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.subSecondsuint timestamp, uint _seconds",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Subtracts seconds from a given timestamp and returns the new timestamp.\n * @dev Internal pure function that performs subtraction and checks for underflow.\n * @param timestamp The original timestamp to subtract from.\n * @param _seconds The number of seconds to subtract.\n * @return newTimestamp The resulting timestamp after subtraction.\n * @dev Reverts if the subtraction would result in an underflow (newTimestamp > timestamp).\n */",
                    "tdd": "{'function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffYears",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _years)",
                    "body": "function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }",
                    "start": "273",
                    "end": "278",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _years) diffYearsuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffYearsuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the difference in years between two timestamps.\n * @dev Internal pure function that requires fromTimestamp to be less than or equal to toTimestamp.\n * \n * Steps:\n * 1. Validates that fromTimestamp is not greater than toTimestamp.\n * 2. Converts both timestamps to year components using _daysToDate helper.\n * 3. Returns the difference between the two years.\n * \n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return _years The number of full years between the two timestamps.\n */",
                    "tdd": "{'function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffMonths",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _months)",
                    "body": "function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }",
                    "start": "279",
                    "end": "284",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _months) diffMonthsuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffMonthsuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the difference in months between two timestamps.\n * \n * @param fromTimestamp The starting timestamp (must be <= toTimestamp).\n * @param toTimestamp The ending timestamp.\n * \n * Steps:\n * 1. Validates that fromTimestamp is less than or equal to toTimestamp.\n * 2. Converts both timestamps to year, month, and day components (day is ignored).\n * 3. Calculates the total months difference by:\n *    - Converting years to months (year * 12)\n *    - Adding the month component\n *    - Subtracting the starting year/month in similar fashion\n * \n * @return _months The number of months between the two timestamps.\n */",
                    "tdd": "{'function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffDays",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _days)",
                    "body": "function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }",
                    "start": "285",
                    "end": "288",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _days) diffDaysuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffDaysuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": " \n/**\n * @notice Calculates the difference in days between two timestamps.\n * @dev The function ensures the 'fromTimestamp' is less than or equal to 'toTimestamp'.\n * @param fromTimestamp The starting timestamp (in seconds).\n * @param toTimestamp The ending timestamp (in seconds).\n * @return _days The number of full days between the two timestamps.\n */",
                    "tdd": "{'function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffHours",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _hours)",
                    "body": "function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }",
                    "start": "289",
                    "end": "292",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _hours) diffHoursuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffHoursuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": "/**\n * @notice Calculates the difference in hours between two timestamps.\n * @dev The function requires that the fromTimestamp is less than or equal to the toTimestamp.\n * @param fromTimestamp The starting timestamp (in seconds).\n * @param toTimestamp The ending timestamp (in seconds).\n * @return _hours The number of hours between the two timestamps.\n */",
                    "tdd": "{'function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffMinutes",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _minutes)",
                    "body": "function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }",
                    "start": "293",
                    "end": "296",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _minutes) diffMinutesuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffMinutesuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": " \n/**\n * @notice Calculates the difference in minutes between two timestamps.\n * @dev The function ensures 'fromTimestamp' is less than or equal to 'toTimestamp'.\n * @param fromTimestamp The starting timestamp (in seconds).\n * @param toTimestamp The ending timestamp (in seconds).\n * @return _minutes The time difference in minutes.\n */",
                    "tdd": "{'function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "diffSeconds",
                    "parameters": "uint fromTimestamp, uint toTimestamp",
                    "modifiers": "pure",
                    "return": "returns (uint _seconds)",
                    "body": "function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }",
                    "start": "297",
                    "end": "300",
                    "class": "BokkyPooBahsDateTimeLibrary",
                    "signature": "returns (uint _seconds) diffSecondsuint fromTimestamp, uint toTimestamp",
                    "full_signature": "function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds)",
                    "class_method_signature": "BokkyPooBahsDateTimeLibrary.diffSecondsuint fromTimestamp, uint toTimestamp",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity >=0.6.0 <0.9.0;"
                    ],
                    "import_directive": "",
                    "llm_comment": " \n/**\n * @notice Calculates the difference in seconds between two timestamps.\n * \n * @param fromTimestamp The starting timestamp (must be <= toTimestamp).\n * @param toTimestamp The ending timestamp.\n * \n * @return _seconds The difference in seconds between the two timestamps.\n * \n * Requirements:  \n * - `fromTimestamp` must be less than or equal to `toTimestamp` to avoid underflow.\n */",
                    "tdd": "{'function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }'}",
                    "context": "set()"
                }
            ]
        }
    ],
    "repository/yui-ibc-solidity/tests/foundry/lib/openzeppelin-foundry-upgrades/src/internal/Utils.sol": [
        {
            "methods": [
                {
                    "identifier": "getFullyQualifiedName",
                    "parameters": "string memory contractName, string memory outDir",
                    "modifiers": "view",
                    "return": "returns (string memory)",
                    "body": "function getFullyQualifiedName(\n        string memory contractName,\n        string memory outDir\n    ) internal view returns (string memory) {\n        ContractInfo memory info = getContractInfo(contractName, outDir);\n        return string(abi.encodePacked(info.contractPath, \":\", info.shortName));\n    }",
                    "start": "44",
                    "end": "50",
                    "class": "Utils",
                    "signature": "returns (string memory) getFullyQualifiedNamestring memory contractName, string memory outDir",
                    "full_signature": "function getFullyQualifiedName(string memory contractName, string memory outDir) internal view returns (string memory)",
                    "class_method_signature": "Utils.getFullyQualifiedNamestring memory contractName, string memory outDir",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Returns the fully qualified name of a contract by combining its path and short name.\n * \n * @param contractName The name of the contract to look up.\n * @param outDir The directory where contract artifacts are stored.\n * \n * @return A string representing the fully qualified name in the format \"contractPath:shortName\".\n * \n * Steps:\n * 1. Retrieve contract information (path and short name) using getContractInfo().\n * 2. Concatenate the contract path and short name with a colon separator.\n * 3. Return the resulting fully qualified name string.\n */",
                    "tdd": "{'function getFullyQualifiedName(\\n        string memory contractName,\\n        string memory outDir\\n    ) internal view returns (string memory) {\\n        ContractInfo memory info = getContractInfo(contractName, outDir);\\n        return string(abi.encodePacked(info.contractPath, \":\", info.shortName));\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "getContractInfo",
                    "parameters": "string memory contractName, string memory outDir",
                    "modifiers": "view",
                    "return": "returns (ContractInfo memory)",
                    "body": "function getContractInfo(\n        string memory contractName,\n        string memory outDir\n    ) internal view returns (ContractInfo memory) {\n        Vm vm = Vm(CHEATCODE_ADDRESS);\n\n        ContractInfo memory info;\n\n        info.shortName = _toShortName(contractName);\n\n        string memory fileName = _toFileName(contractName);\n\n        string memory artifactPath = string(\n            abi.encodePacked(vm.projectRoot(), \"/\", outDir, \"/\", fileName, \"/\", info.shortName, \".json\")\n        );\n        string memory artifactJson = vm.readFile(artifactPath);\n\n        if (!vm.keyExistsJson(artifactJson, \".ast\")) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Could not find AST in artifact \",\n                        artifactPath,\n                        \". Set `ast = true` in foundry.toml\"\n                    )\n                )\n            );\n        }\n        info.contractPath = vm.parseJsonString(artifactJson, \".ast.absolutePath\");\n        if (vm.keyExistsJson(artifactJson, \".ast.license\")) {\n            info.license = vm.parseJsonString(artifactJson, \".ast.license\");\n        }\n        info.sourceCodeHash = vm.parseJsonString(\n            artifactJson,\n            string(abi.encodePacked(\".metadata.sources.['\", info.contractPath, \"'].keccak256\"))\n        );\n        info.artifactPath = artifactPath;\n\n        return info;\n    }",
                    "start": "59",
                    "end": "98",
                    "class": "Utils",
                    "signature": "returns (ContractInfo memory) getContractInfostring memory contractName, string memory outDir",
                    "full_signature": "function getContractInfo(string memory contractName, string memory outDir) internal view returns (ContractInfo memory)",
                    "class_method_signature": "Utils.getContractInfostring memory contractName, string memory outDir",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Retrieves contract information from artifact files.\n * @param contractName The name of the contract to get information for.\n * @param outDir The output directory where artifacts are stored.\n * @return info A ContractInfo struct containing contract details.\n *\n * Steps:\n * 1. Initialize VM instance for cheatcodes.\n * 2. Create empty ContractInfo struct.\n * 3. Generate short name and file name from contract name.\n * 4. Construct artifact path using project root, output directory, and file names.\n * 5. Read artifact JSON file.\n * 6. Verify AST exists in artifact, revert if not found.\n * 7. Parse contract path from artifact AST.\n * 8. If exists, parse license information from artifact.\n * 9. Parse source code hash from artifact metadata.\n * 10. Store artifact path in info struct.\n * 11. Return populated ContractInfo struct.\n *\n * Reverts:\n * - If AST is not found in artifact (with instructions to enable AST in foundry.toml)\n */",
                    "tdd": "{'function getContractInfo(\\n        string memory contractName,\\n        string memory outDir\\n    ) internal view returns (ContractInfo memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        ContractInfo memory info;\\n\\n        info.shortName = _toShortName(contractName);\\n\\n        string memory fileName = _toFileName(contractName);\\n\\n        string memory artifactPath = string(\\n            abi.encodePacked(vm.projectRoot(), \"/\", outDir, \"/\", fileName, \"/\", info.shortName, \".json\")\\n        );\\n        string memory artifactJson = vm.readFile(artifactPath);\\n\\n        if (!vm.keyExistsJson(artifactJson, \".ast\")) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Could not find AST in artifact \",\\n                        artifactPath,\\n                        \". Set `ast = true` in foundry.toml\"\\n                    )\\n                )\\n            );\\n        }\\n        info.contractPath = vm.parseJsonString(artifactJson, \".ast.absolutePath\");\\n        if (vm.keyExistsJson(artifactJson, \".ast.license\")) {\\n            info.license = vm.parseJsonString(artifactJson, \".ast.license\");\\n        }\\n        info.sourceCodeHash = vm.parseJsonString(\\n            artifactJson,\\n            string(abi.encodePacked(\".metadata.sources.[\\'\", info.contractPath, \"\\'].keccak256\"))\\n        );\\n        info.artifactPath = artifactPath;\\n\\n        return info;\\n    }'}",
                    "context": "{'function parseJsonString(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (string memory);', 'function projectRoot() external view returns (string memory path);', 'function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);', 'function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }', 'function keyExistsJson(string calldata json, string calldata key)\\n        external\\n        view\\n        returns (bool);', 'function parseJson(string calldata json, string calldata key)\\n        external\\n        pure\\n        returns (bytes memory abiEncodedData);', 'function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }', 'function keyExists(string calldata json, string calldata key) external view returns (bool);', 'function readFile(string calldata path) external view returns (string memory data);'}"
                },
                {
                    "identifier": "getBuildInfoFile",
                    "parameters": "string memory sourceCodeHash, string memory contractName, string memory outDir",
                    "modifiers": "",
                    "return": "returns (string memory)",
                    "body": "function getBuildInfoFile(\n        string memory sourceCodeHash,\n        string memory contractName,\n        string memory outDir\n    ) internal returns (string memory) {\n        string[] memory inputs = new string[](4);\n        inputs[0] = \"grep\";\n        inputs[1] = \"-rl\";\n        inputs[2] = string(abi.encodePacked('\"', sourceCodeHash, '\"'));\n        inputs[3] = string(abi.encodePacked(outDir, \"/build-info\"));\n\n        Vm.FfiResult memory result = runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (!stdout.toSlice().endsWith(\".json\".toSlice())) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Could not find build-info file with matching source code hash for contract \",\n                        contractName\n                    )\n                )\n            );\n        }\n\n        return stdout;\n    }",
                    "start": "110",
                    "end": "136",
                    "class": "Utils",
                    "signature": "returns (string memory) getBuildInfoFilestring memory sourceCodeHash, string memory contractName, string memory outDir",
                    "full_signature": "function getBuildInfoFile(string memory sourceCodeHash, string memory contractName, string memory outDir) internal returns (string memory)",
                    "class_method_signature": "Utils.getBuildInfoFilestring memory sourceCodeHash, string memory contractName, string memory outDir",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Retrieves the build info file path for a contract with matching source code hash.\n * @dev Uses grep to search for the source code hash in build-info directory.\n * \n * Steps:\n * 1. Prepares grep command inputs to search for the source code hash.\n * 2. Executes the command via FFI (Foreign Function Interface).\n * 3. Checks if the output ends with \".json\" extension.\n * 4. Reverts if no matching build-info file is found.\n * 5. Returns the file path if found.\n * \n * @param sourceCodeHash The hash of the contract's source code to search for.\n * @param contractName The name of the contract (used in error message).\n * @param outDir The output directory containing build-info files.\n * @return The path to the matching build-info JSON file.\n * @throws Reverts if no matching build-info file is found.\n */",
                    "tdd": "{'function getBuildInfoFile(\\n        string memory sourceCodeHash,\\n        string memory contractName,\\n        string memory outDir\\n    ) internal returns (string memory) {\\n        string[] memory inputs = new string[](4);\\n        inputs[0] = \"grep\";\\n        inputs[1] = \"-rl\";\\n        inputs[2] = string(abi.encodePacked(\\'\"\\', sourceCodeHash, \\'\"\\'));\\n        inputs[3] = string(abi.encodePacked(outDir, \"/build-info\"));\\n\\n        Vm.FfiResult memory result = runAsBashCommand(inputs);\\n        string memory stdout = string(result.stdout);\\n\\n        if (!stdout.toSlice().endsWith(\".json\".toSlice())) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Could not find build-info file with matching source code hash for contract \",\\n                        contractName\\n                    )\\n                )\\n            );\\n        }\\n\\n        return stdout;\\n    }'}",
                    "context": "{'function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }', 'function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }', 'function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }', 'struct FfiResult {\\n        // The exit code of the call.\\n        int32 exitCode;\\n        // The optionally hex-decoded `stdout` data.\\n        bytes stdout;\\n        // The `stderr` data.\\n        bytes stderr;\\n    }'}"
                },
                {
                    "identifier": "getOutDir",
                    "parameters": "",
                    "modifiers": "view",
                    "return": "returns (string memory)",
                    "body": "function getOutDir() internal view returns (string memory) {\n        Vm vm = Vm(CHEATCODE_ADDRESS);\n\n        string memory defaultOutDir = \"out\";\n        return vm.envOr(\"FOUNDRY_OUT\", defaultOutDir);\n    }",
                    "start": "141",
                    "end": "146",
                    "class": "Utils",
                    "signature": "returns (string memory) getOutDir",
                    "full_signature": "function getOutDir() internal view returns (string memory)",
                    "class_method_signature": "Utils.getOutDir",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";"
                    ],
                    "llm_comment": " \n/**\n * @notice Gets the output directory path for Foundry.  \n *  \n * Steps:  \n * 1. Initialize the Vm cheatcode interface.  \n * 2. Set the default output directory as \"out\".  \n * 3. Return the directory path from the environment variable \"FOUNDRY_OUT\" if set, otherwise return the default.  \n */  ",
                    "tdd": "{'function getOutDir() internal view returns (string memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        string memory defaultOutDir = \"out\";\\n        return vm.envOr(\"FOUNDRY_OUT\", defaultOutDir);\\n    }'}",
                    "context": "{'function envOr(string calldata name, bytes calldata defaultValue)\\n        external\\n        view\\n        returns (bytes memory value);', 'function envOr(string calldata name, string calldata defaultValue)\\n        external\\n        view\\n        returns (string memory value);', 'function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)\\n        external\\n        view\\n        returns (bool[] memory value);', 'function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)\\n        external\\n        view\\n        returns (int256[] memory value);', 'function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)\\n        external\\n        view\\n        returns (bytes[] memory value);', 'function envOr(string calldata name, int256 defaultValue)\\n        external\\n        view\\n        returns (int256 value);', 'function envOr(string calldata name, bool defaultValue) external view returns (bool value);', 'function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)\\n        external\\n        view\\n        returns (address[] memory value);', 'function envOr(string calldata name, bytes32 defaultValue)\\n        external\\n        view\\n        returns (bytes32 value);', 'function envOr(string calldata name, uint256 defaultValue)\\n        external\\n        view\\n        returns (uint256 value);', 'function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)\\n        external\\n        view\\n        returns (bytes32[] memory value);', 'function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)\\n        external\\n        view\\n        returns (uint256[] memory value);', 'function envOr(string calldata name, address defaultValue)\\n        external\\n        view\\n        returns (address value);', 'function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)\\n        external\\n        view\\n        returns (string[] memory value);'}"
                },
                {
                    "identifier": "toBashCommand",
                    "parameters": "string[] memory inputs, string memory bashPath",
                    "modifiers": "pure",
                    "return": "returns (string[] memory)",
                    "body": "function toBashCommand(string[] memory inputs, string memory bashPath) internal pure returns (string[] memory) {\n        string memory commandString;\n        for (uint i = 0; i < inputs.length; i++) {\n            commandString = string(abi.encodePacked(commandString, inputs[i]));\n            if (i != inputs.length - 1) {\n                commandString = string(abi.encodePacked(commandString, \" \"));\n            }\n        }\n\n        string[] memory result = new string[](3);\n        result[0] = bashPath;\n        result[1] = \"-c\";\n        result[2] = commandString;\n        return result;\n    }",
                    "start": "215",
                    "end": "229",
                    "class": "Utils",
                    "signature": "returns (string[] memory) toBashCommandstring[] memory inputs, string memory bashPath",
                    "full_signature": "function toBashCommand(string[] memory inputs, string memory bashPath) internal pure returns (string[] memory)",
                    "class_method_signature": "Utils.toBashCommandstring[] memory inputs, string memory bashPath",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Converts an array of input strings into a bash command format.\n * @param inputs An array of strings representing command parts.\n * @param bashPath The path to the bash executable.\n * @return result An array of strings formatted as a bash command:\n *   - result[0]: bashPath\n *   - result[1]: \"-c\" flag\n *   - result[2]: The concatenated command string from inputs\n *\n * Process:\n * 1. Initialize an empty command string.\n * 2. Iterate through each input string:\n *    - Append each input to the command string\n *    - Add a space between inputs (except for the last one)\n * 3. Create a result array with 3 elements:\n *    - bashPath as first element\n *    - \"-c\" flag as second element\n *    - The constructed command string as third element\n * 4. Return the formatted bash command array.\n */",
                    "tdd": "{'function toBashCommand(string[] memory inputs, string memory bashPath) internal pure returns (string[] memory) {\\n        string memory commandString;\\n        for (uint i = 0; i < inputs.length; i++) {\\n            commandString = string(abi.encodePacked(commandString, inputs[i]));\\n            if (i != inputs.length - 1) {\\n                commandString = string(abi.encodePacked(commandString, \" \"));\\n            }\\n        }\\n\\n        string[] memory result = new string[](3);\\n        result[0] = bashPath;\\n        result[1] = \"-c\";\\n        result[2] = commandString;\\n        return result;\\n    }'}",
                    "context": "{'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }'}"
                }
            ]
        }
    ],
    "repository/yui-ibc-solidity/tests/foundry/lib/openzeppelin-foundry-upgrades/src/internal/DefenderDeploy.sol": [
        {
            "methods": [
                {
                    "identifier": "deploy",
                    "parameters": "string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "modifiers": "",
                    "return": "returns (address)",
                    "body": "function deploy(\n        string memory contractName,\n        bytes memory constructorData,\n        DefenderOptions memory defenderOpts\n    ) internal returns (address) {\n        string memory outDir = Utils.getOutDir();\n        ContractInfo memory contractInfo = Utils.getContractInfo(contractName, outDir);\n        string memory buildInfoFile = Utils.getBuildInfoFile(\n            contractInfo.sourceCodeHash,\n            contractInfo.shortName,\n            outDir\n        );\n\n        string[] memory inputs = buildDeployCommand(contractInfo, buildInfoFile, constructorData, defenderOpts);\n\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (result.exitCode != 0) {\n            revert(string(abi.encodePacked(\"Failed to deploy contract \", contractName, \": \", string(result.stderr))));\n        }\n\n        string memory deployedAddress = _parseLine(\"Deployed to address: \", stdout, true);\n        return Vm(Utils.CHEATCODE_ADDRESS).parseAddress(deployedAddress);\n    }",
                    "start": "23",
                    "end": "47",
                    "class": "DefenderDeploy",
                    "signature": "returns (address) deploystring memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "full_signature": "function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal returns (address)",
                    "class_method_signature": "DefenderDeploy.deploystring memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": " \n/**\n * @notice Deploys a contract using Foundry's FFI and returns its address.\n *\n * Steps:\n * 1. Retrieves the output directory path.\n * 2. Fetches contract info (source hash, short name) for the given contract name.\n * 3. Constructs the build info file path.\n *\n * 4. Builds the deployment command using contract info, build file, constructor data, and Defender options.\n * 5. Executes the command as a bash script using Foundry FFI.\n * 6. Checks if the deployment was successful (exit code 0).\n *    - Reverts with an error message if deployment fails.\n *\n * 7. Parses the deployed contract address from the command output.\n * 8. Converts the address string to an Ethereum address and returns it.\n *\n * @param contractName Name of the contract to deploy.\n * @param constructorData Encoded constructor arguments for deployment.\n * @param defenderOpts Additional deployment options (e.g., verification, gas settings).\n * @return address The deployed contract's address.\n */",
                    "tdd": "{'function deploy(\\n        string memory contractName,\\n        bytes memory constructorData,\\n        DefenderOptions memory defenderOpts\\n    ) internal returns (address) {\\n        string memory outDir = Utils.getOutDir();\\n        ContractInfo memory contractInfo = Utils.getContractInfo(contractName, outDir);\\n        string memory buildInfoFile = Utils.getBuildInfoFile(\\n            contractInfo.sourceCodeHash,\\n            contractInfo.shortName,\\n            outDir\\n        );\\n\\n        string[] memory inputs = buildDeployCommand(contractInfo, buildInfoFile, constructorData, defenderOpts);\\n\\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\\n        string memory stdout = string(result.stdout);\\n\\n        if (result.exitCode != 0) {\\n            revert(string(abi.encodePacked(\"Failed to deploy contract \", contractName, \": \", string(result.stderr))));\\n        }\\n\\n        string memory deployedAddress = _parseLine(\"Deployed to address: \", stdout, true);\\n        return Vm(Utils.CHEATCODE_ADDRESS).parseAddress(deployedAddress);\\n    }'}",
                    "context": "{'function parseAddress(string memory input) internal pure returns (address) {\\n        return parseAddress(input, 0, bytes(input).length);\\n    }', 'function runAsBashCommand(string[] memory inputs) internal returns (Vm.FfiResult memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n        string memory defaultBashPath = \"bash\";\\n        string memory bashPath = vm.envOr(\"OPENZEPPELIN_BASH_PATH\", defaultBashPath);\\n\\n        string[] memory bashCommand = toBashCommand(inputs, bashPath);\\n        Vm.FfiResult memory result = vm.tryFfi(bashCommand);\\n        if (result.exitCode != 0 && result.stdout.length == 0 && result.stderr.length == 0) {\\n            // On Windows, using the bash executable from WSL leads to a non-zero exit code and no output\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\'Failed to run bash command with \"\\',\\n                        bashCommand[0],\\n                        \\'\". If you are using Windows, set the OPENZEPPELIN_BASH_PATH environment variable to the fully qualified path of the bash executable. For example, if you are using Git for Windows, add the following line in the .env file of your project (using forward slashes):\\\\nOPENZEPPELIN_BASH_PATH=\"C:/Program Files/Git/bin/bash\"\\'\\n                    )\\n                )\\n            );\\n        } else {\\n            return result;\\n        }\\n    }', 'function getContractInfo(\\n        string memory contractName,\\n        string memory outDir\\n    ) internal view returns (ContractInfo memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        ContractInfo memory info;\\n\\n        info.shortName = _toShortName(contractName);\\n\\n        string memory fileName = _toFileName(contractName);\\n\\n        string memory artifactPath = string(\\n            abi.encodePacked(vm.projectRoot(), \"/\", outDir, \"/\", fileName, \"/\", info.shortName, \".json\")\\n        );\\n        string memory artifactJson = vm.readFile(artifactPath);\\n\\n        if (!vm.keyExistsJson(artifactJson, \".ast\")) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Could not find AST in artifact \",\\n                        artifactPath,\\n                        \". Set `ast = true` in foundry.toml\"\\n                    )\\n                )\\n            );\\n        }\\n        info.contractPath = vm.parseJsonString(artifactJson, \".ast.absolutePath\");\\n        if (vm.keyExistsJson(artifactJson, \".ast.license\")) {\\n            info.license = vm.parseJsonString(artifactJson, \".ast.license\");\\n        }\\n        info.sourceCodeHash = vm.parseJsonString(\\n            artifactJson,\\n            string(abi.encodePacked(\".metadata.sources.[\\'\", info.contractPath, \"\\'].keccak256\"))\\n        );\\n        info.artifactPath = artifactPath;\\n\\n        return info;\\n    }', 'function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\\n        (bool success, address value) = tryParseAddress(input, begin, end);\\n        if (!success) revert StringsInvalidAddressFormat();\\n        return value;\\n    }', 'function getOutDir() internal view returns (string memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        string memory defaultOutDir = \"out\";\\n        return vm.envOr(\"FOUNDRY_OUT\", defaultOutDir);\\n    }', 'function parseAddress(string calldata stringifiedValue)\\n        external\\n        pure\\n        returns (address parsedValue);', 'function addr(uint256 privateKey) external pure returns (address keyAddr);', 'function getBuildInfoFile(\\n        string memory sourceCodeHash,\\n        string memory contractName,\\n        string memory outDir\\n    ) internal returns (string memory) {\\n        string[] memory inputs = new string[](4);\\n        inputs[0] = \"grep\";\\n        inputs[1] = \"-rl\";\\n        inputs[2] = string(abi.encodePacked(\\'\"\\', sourceCodeHash, \\'\"\\'));\\n        inputs[3] = string(abi.encodePacked(outDir, \"/build-info\"));\\n\\n        Vm.FfiResult memory result = runAsBashCommand(inputs);\\n        string memory stdout = string(result.stdout);\\n\\n        if (!stdout.toSlice().endsWith(\".json\".toSlice())) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Could not find build-info file with matching source code hash for contract \",\\n                        contractName\\n                    )\\n                )\\n            );\\n        }\\n\\n        return stdout;\\n    }', 'struct FfiResult {\\n        // The exit code of the call.\\n        int32 exitCode;\\n        // The optionally hex-decoded `stdout` data.\\n        bytes stdout;\\n        // The `stderr` data.\\n        bytes stderr;\\n    }', 'address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;'}"
                },
                {
                    "identifier": "buildDeployCommand",
                    "parameters": "ContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "modifiers": "view",
                    "return": "returns (string[] memory)",
                    "body": "function buildDeployCommand(\n        ContractInfo memory contractInfo,\n        string memory buildInfoFile,\n        bytes memory constructorData,\n        DefenderOptions memory defenderOpts\n    ) internal view returns (string[] memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        if (!(defenderOpts.licenseType).toSlice().empty()) {\n            if (defenderOpts.skipVerifySourceCode) {\n                revert(\"The `licenseType` option cannot be used when the `skipVerifySourceCode` option is `true`\");\n            } else if (defenderOpts.skipLicenseType) {\n                revert(\"The `licenseType` option cannot be used when the `skipLicenseType` option is `true`\");\n            }\n        }\n\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = \"deploy\";\n        inputBuilder[i++] = \"--contractName\";\n        inputBuilder[i++] = contractInfo.shortName;\n        inputBuilder[i++] = \"--contractPath\";\n        inputBuilder[i++] = contractInfo.contractPath;\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n        inputBuilder[i++] = \"--buildInfoFile\";\n        inputBuilder[i++] = buildInfoFile;\n        if (constructorData.length > 0) {\n            inputBuilder[i++] = \"--constructorBytecode\";\n            inputBuilder[i++] = vm.toString(constructorData);\n        }\n        if (defenderOpts.skipVerifySourceCode) {\n            inputBuilder[i++] = \"--verifySourceCode\";\n            inputBuilder[i++] = \"false\";\n        } else if (!(defenderOpts.licenseType).toSlice().empty()) {\n            inputBuilder[i++] = \"--licenseType\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', defenderOpts.licenseType, '\"'));\n        } else if (!defenderOpts.skipLicenseType && !(contractInfo.license).toSlice().empty()) {\n            inputBuilder[i++] = \"--licenseType\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', _toLicenseType(contractInfo), '\"'));\n        }\n        if (!(defenderOpts.relayerId).toSlice().empty()) {\n            inputBuilder[i++] = \"--relayerId\";\n            inputBuilder[i++] = defenderOpts.relayerId;\n        }\n        if (defenderOpts.salt != 0) {\n            inputBuilder[i++] = \"--salt\";\n            inputBuilder[i++] = vm.toString(defenderOpts.salt);\n        }\n        if (defenderOpts.txOverrides.gasLimit != 0) {\n            inputBuilder[i++] = \"--gasLimit\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasLimit);\n        }\n        if (defenderOpts.txOverrides.gasPrice != 0) {\n            inputBuilder[i++] = \"--gasPrice\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasPrice);\n        }\n        if (defenderOpts.txOverrides.maxFeePerGas != 0) {\n            inputBuilder[i++] = \"--maxFeePerGas\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxFeePerGas);\n        }\n        if (defenderOpts.txOverrides.maxPriorityFeePerGas != 0) {\n            inputBuilder[i++] = \"--maxPriorityFeePerGas\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxPriorityFeePerGas);\n        }\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
                    "start": "49",
                    "end": "128",
                    "class": "DefenderDeploy",
                    "signature": "returns (string[] memory) buildDeployCommandContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "full_signature": "function buildDeployCommand(ContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts) internal view returns (string[] memory)",
                    "class_method_signature": "DefenderDeploy.buildDeployCommandContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Builds a deploy command for OpenZeppelin Defender deployment.\n * @dev Constructs a command array for deploying contracts through Defender CLI.\n *\n * Steps:\n * 1. Initialize VM instance for cheatcodes.\n * 2. Validate licenseType options (cannot be used with skipVerifySourceCode or skipLicenseType).\n * 3. Initialize an input string array with maximum possible length.\n * 4. Build the base deploy command with:\n *    - CLI tool path and version\n *    - Contract name and path\n *    - Chain ID\n *    - Build info file\n * 5. Add optional parameters if provided:\n *    - Constructor bytecode\n *    - Verification options (skipVerifySourceCode, licenseType)\n *    - Relayer ID\n *    - Deployment salt\n *    - Transaction overrides (gasLimit, gasPrice, maxFeePerGas, maxPriorityFeePerGas)\n * 6. Create a properly sized copy of the input array.\n * 7. Return the final command array.\n *\n * @param contractInfo Contains contract metadata (name, path, license).\n * @param buildInfoFile Path to build info file.\n * @param constructorData Bytecode for constructor arguments.\n * @param defenderOpts Deployment options including verification settings and tx overrides.\n * @return inputs Array of strings forming the complete deploy command.\n */",
                    "tdd": "{'function buildDeployCommand(\\n        ContractInfo memory contractInfo,\\n        string memory buildInfoFile,\\n        bytes memory constructorData,\\n        DefenderOptions memory defenderOpts\\n    ) internal view returns (string[] memory) {\\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\\n\\n        if (!(defenderOpts.licenseType).toSlice().empty()) {\\n            if (defenderOpts.skipVerifySourceCode) {\\n                revert(\"The `licenseType` option cannot be used when the `skipVerifySourceCode` option is `true`\");\\n            } else if (defenderOpts.skipLicenseType) {\\n                revert(\"The `licenseType` option cannot be used when the `skipLicenseType` option is `true`\");\\n            }\\n        }\\n\\n        string[] memory inputBuilder = new string[](255);\\n\\n        uint8 i = 0;\\n\\n        inputBuilder[i++] = \"npx\";\\n        inputBuilder[i++] = string(\\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\\n        );\\n        inputBuilder[i++] = \"deploy\";\\n        inputBuilder[i++] = \"--contractName\";\\n        inputBuilder[i++] = contractInfo.shortName;\\n        inputBuilder[i++] = \"--contractPath\";\\n        inputBuilder[i++] = contractInfo.contractPath;\\n        inputBuilder[i++] = \"--chainId\";\\n        inputBuilder[i++] = Strings.toString(block.chainid);\\n        inputBuilder[i++] = \"--buildInfoFile\";\\n        inputBuilder[i++] = buildInfoFile;\\n        if (constructorData.length > 0) {\\n            inputBuilder[i++] = \"--constructorBytecode\";\\n            inputBuilder[i++] = vm.toString(constructorData);\\n        }\\n        if (defenderOpts.skipVerifySourceCode) {\\n            inputBuilder[i++] = \"--verifySourceCode\";\\n            inputBuilder[i++] = \"false\";\\n        } else if (!(defenderOpts.licenseType).toSlice().empty()) {\\n            inputBuilder[i++] = \"--licenseType\";\\n            inputBuilder[i++] = string(abi.encodePacked(\\'\"\\', defenderOpts.licenseType, \\'\"\\'));\\n        } else if (!defenderOpts.skipLicenseType && !(contractInfo.license).toSlice().empty()) {\\n            inputBuilder[i++] = \"--licenseType\";\\n            inputBuilder[i++] = string(abi.encodePacked(\\'\"\\', _toLicenseType(contractInfo), \\'\"\\'));\\n        }\\n        if (!(defenderOpts.relayerId).toSlice().empty()) {\\n            inputBuilder[i++] = \"--relayerId\";\\n            inputBuilder[i++] = defenderOpts.relayerId;\\n        }\\n        if (defenderOpts.salt != 0) {\\n            inputBuilder[i++] = \"--salt\";\\n            inputBuilder[i++] = vm.toString(defenderOpts.salt);\\n        }\\n        if (defenderOpts.txOverrides.gasLimit != 0) {\\n            inputBuilder[i++] = \"--gasLimit\";\\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasLimit);\\n        }\\n        if (defenderOpts.txOverrides.gasPrice != 0) {\\n            inputBuilder[i++] = \"--gasPrice\";\\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasPrice);\\n        }\\n        if (defenderOpts.txOverrides.maxFeePerGas != 0) {\\n            inputBuilder[i++] = \"--maxFeePerGas\";\\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxFeePerGas);\\n        }\\n        if (defenderOpts.txOverrides.maxPriorityFeePerGas != 0) {\\n            inputBuilder[i++] = \"--maxPriorityFeePerGas\";\\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxPriorityFeePerGas);\\n        }\\n\\n        // Create a copy of inputs but with the correct length\\n        string[] memory inputs = new string[](i);\\n        for (uint8 j = 0; j < i; j++) {\\n            inputs[j] = inputBuilder[j];\\n        }\\n\\n        return inputs;\\n    }'}",
                    "context": "{'VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));', 'function maxFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\\n        return uint128(self.gasFees.extract_32_16(16));\\n    }', 'function toString(bool value) external pure returns (string memory stringifiedValue);', 'function maxPriorityFeePerGas(PackedUserOperation calldata self) internal pure returns (uint256) {\\n        return uint128(self.gasFees.extract_32_16(0));\\n    }', 'function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }', 'function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }', 'address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;', 'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function chainId(uint256 newChainId) external;', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }', 'function toString(address value) external pure returns (string memory stringifiedValue);', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.7\";', 'function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.9\";', 'function toString(uint256 value) external pure returns (string memory stringifiedValue);', 'function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }', 'function gasPrice(PackedUserOperation calldata self) internal view returns (uint256) {\\n        unchecked {\\n            // Following values are \"per gas\"\\n            uint256 maxPriorityFee = maxPriorityFeePerGas(self);\\n            uint256 maxFee = maxFeePerGas(self);\\n            return Math.min(maxFee, maxPriorityFee + block.basefee);\\n        }\\n    }', 'function skip(bool skipTest) external;', 'function toString(bytes32 value) external pure returns (string memory stringifiedValue);', 'function toString(bytes calldata value)\\n        external\\n        pure\\n        returns (string memory stringifiedValue);', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\"memory-safe\") {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\"memory-safe\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'function toString(int256 value) external pure returns (string memory stringifiedValue);'}"
                },
                {
                    "identifier": "proposeUpgrade",
                    "parameters": "address proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
                    "modifiers": "",
                    "return": "returns (ProposeUpgradeResponse memory)",
                    "body": "function proposeUpgrade(\n        address proxyAddress,\n        address proxyAdminAddress,\n        address newImplementationAddress,\n        string memory newImplementationContractName,\n        Options memory opts\n    ) internal returns (ProposeUpgradeResponse memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        string memory outDir = Utils.getOutDir();\n        ContractInfo memory contractInfo = Utils.getContractInfo(newImplementationContractName, outDir);\n\n        string[] memory inputs = buildProposeUpgradeCommand(\n            proxyAddress,\n            proxyAdminAddress,\n            newImplementationAddress,\n            contractInfo,\n            opts\n        );\n\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (result.exitCode != 0) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Failed to propose upgrade for proxy \",\n                        vm.toString(proxyAddress),\n                        \": \",\n                        string(result.stderr)\n                    )\n                )\n            );\n        }\n\n        return parseProposeUpgradeResponse(stdout);\n    }",
                    "start": "175",
                    "end": "212",
                    "class": "DefenderDeploy",
                    "signature": "returns (ProposeUpgradeResponse memory) proposeUpgradeaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
                    "full_signature": "function proposeUpgrade(address proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts) internal returns (ProposeUpgradeResponse memory)",
                    "class_method_signature": "DefenderDeploy.proposeUpgradeaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": " \n/**  \n * @notice Proposes an upgrade for a proxy contract using the specified implementation.  \n *  \n * Steps:  \n * 1. Initialize the VM environment for cheatcode access.  \n * 2. Retrieve the output directory path.  \n * 3. Fetch contract info (ABI, bytecode, etc.) for the new implementation contract.  \n *  \n * 4. Build the command inputs for proposing the upgrade.  \n * 5. Execute the upgrade proposal as a bash command.  \n * 6. Capture the command output.  \n *  \n * 7. Check if the command failed (non-zero exit code).  \n * 8. If failed, revert with an error message containing proxy address and stderr.  \n *  \n * 9. If successful, parse and return the upgrade proposal response from stdout.  \n *  \n * @param proxyAddress The address of the proxy contract to upgrade.  \n * @param proxyAdminAddress The address of the proxy admin.  \n * @param newImplementationAddress The address of the new implementation contract.  \n * @param newImplementationContractName The name of the new implementation contract.  \n * @param opts Additional options for the upgrade proposal.  \n * @return ProposeUpgradeResponse Parsed response from the upgrade proposal.  \n */  ",
                    "tdd": "{'function proposeUpgrade(\\n        address proxyAddress,\\n        address proxyAdminAddress,\\n        address newImplementationAddress,\\n        string memory newImplementationContractName,\\n        Options memory opts\\n    ) internal returns (ProposeUpgradeResponse memory) {\\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\\n\\n        string memory outDir = Utils.getOutDir();\\n        ContractInfo memory contractInfo = Utils.getContractInfo(newImplementationContractName, outDir);\\n\\n        string[] memory inputs = buildProposeUpgradeCommand(\\n            proxyAddress,\\n            proxyAdminAddress,\\n            newImplementationAddress,\\n            contractInfo,\\n            opts\\n        );\\n\\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\\n        string memory stdout = string(result.stdout);\\n\\n        if (result.exitCode != 0) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Failed to propose upgrade for proxy \",\\n                        vm.toString(proxyAddress),\\n                        \": \",\\n                        string(result.stderr)\\n                    )\\n                )\\n            );\\n        }\\n\\n        return parseProposeUpgradeResponse(stdout);\\n    }'}",
                    "context": "{'function toString(int256 value) external pure returns (string memory stringifiedValue);', 'function runAsBashCommand(string[] memory inputs) internal returns (Vm.FfiResult memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n        string memory defaultBashPath = \"bash\";\\n        string memory bashPath = vm.envOr(\"OPENZEPPELIN_BASH_PATH\", defaultBashPath);\\n\\n        string[] memory bashCommand = toBashCommand(inputs, bashPath);\\n        Vm.FfiResult memory result = vm.tryFfi(bashCommand);\\n        if (result.exitCode != 0 && result.stdout.length == 0 && result.stderr.length == 0) {\\n            // On Windows, using the bash executable from WSL leads to a non-zero exit code and no output\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\'Failed to run bash command with \"\\',\\n                        bashCommand[0],\\n                        \\'\". If you are using Windows, set the OPENZEPPELIN_BASH_PATH environment variable to the fully qualified path of the bash executable. For example, if you are using Git for Windows, add the following line in the .env file of your project (using forward slashes):\\\\nOPENZEPPELIN_BASH_PATH=\"C:/Program Files/Git/bin/bash\"\\'\\n                    )\\n                )\\n            );\\n        } else {\\n            return result;\\n        }\\n    }', 'function toString(address value) external pure returns (string memory stringifiedValue);', 'function proposeUpgrade(\\n        address proxyAddress,\\n        string memory newImplementationContractName,\\n        Options memory opts\\n    ) internal returns (ProposeUpgradeResponse memory) {\\n        opts.defender.useDefenderDeploy = true;\\n        address proxyAdminAddress = Core.getAdminAddress(proxyAddress);\\n        address newImplementationAddress = Core.prepareUpgrade(newImplementationContractName, opts);\\n        return\\n            DefenderDeploy.proposeUpgrade(\\n                proxyAddress,\\n                proxyAdminAddress,\\n                newImplementationAddress,\\n                newImplementationContractName,\\n                opts\\n            );\\n    }', 'VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));', 'function getContractInfo(\\n        string memory contractName,\\n        string memory outDir\\n    ) internal view returns (ContractInfo memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        ContractInfo memory info;\\n\\n        info.shortName = _toShortName(contractName);\\n\\n        string memory fileName = _toFileName(contractName);\\n\\n        string memory artifactPath = string(\\n            abi.encodePacked(vm.projectRoot(), \"/\", outDir, \"/\", fileName, \"/\", info.shortName, \".json\")\\n        );\\n        string memory artifactJson = vm.readFile(artifactPath);\\n\\n        if (!vm.keyExistsJson(artifactJson, \".ast\")) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \"Could not find AST in artifact \",\\n                        artifactPath,\\n                        \". Set `ast = true` in foundry.toml\"\\n                    )\\n                )\\n            );\\n        }\\n        info.contractPath = vm.parseJsonString(artifactJson, \".ast.absolutePath\");\\n        if (vm.keyExistsJson(artifactJson, \".ast.license\")) {\\n            info.license = vm.parseJsonString(artifactJson, \".ast.license\");\\n        }\\n        info.sourceCodeHash = vm.parseJsonString(\\n            artifactJson,\\n            string(abi.encodePacked(\".metadata.sources.[\\'\", info.contractPath, \"\\'].keccak256\"))\\n        );\\n        info.artifactPath = artifactPath;\\n\\n        return info;\\n    }', 'function toString(bool value) external pure returns (string memory stringifiedValue);', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'function getOutDir() internal view returns (string memory) {\\n        Vm vm = Vm(CHEATCODE_ADDRESS);\\n\\n        string memory defaultOutDir = \"out\";\\n        return vm.envOr(\"FOUNDRY_OUT\", defaultOutDir);\\n    }', 'function toString(bytes calldata value)\\n        external\\n        pure\\n        returns (string memory stringifiedValue);', 'function toString(bytes32 value) external pure returns (string memory stringifiedValue);', 'function toString(uint256 value) external pure returns (string memory stringifiedValue);', 'function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\"memory-safe\") {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\"memory-safe\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'function addr(uint256 privateKey) external pure returns (address keyAddr);', 'struct FfiResult {\\n        // The exit code of the call.\\n        int32 exitCode;\\n        // The optionally hex-decoded `stdout` data.\\n        bytes stdout;\\n        // The `stderr` data.\\n        bytes stderr;\\n    }', 'address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;'}"
                },
                {
                    "identifier": "parseProposeUpgradeResponse",
                    "parameters": "string memory stdout",
                    "modifiers": "pure",
                    "return": "returns (ProposeUpgradeResponse memory)",
                    "body": "function parseProposeUpgradeResponse(string memory stdout) internal pure returns (ProposeUpgradeResponse memory) {\n        ProposeUpgradeResponse memory response;\n        response.proposalId = _parseLine(\"Proposal ID: \", stdout, true);\n        response.url = _parseLine(\"Proposal URL: \", stdout, false);\n        return response;\n    }",
                    "start": "214",
                    "end": "219",
                    "class": "DefenderDeploy",
                    "signature": "returns (ProposeUpgradeResponse memory) parseProposeUpgradeResponsestring memory stdout",
                    "full_signature": "function parseProposeUpgradeResponse(string memory stdout) internal pure returns (ProposeUpgradeResponse memory)",
                    "class_method_signature": "DefenderDeploy.parseProposeUpgradeResponsestring memory stdout",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": " \n/**\n * @notice Parses the stdout response from a propose upgrade command into a structured ProposeUpgradeResponse object.\n * \n * Steps:  \n * 1. Creates an empty ProposeUpgradeResponse struct in memory.  \n * 2. Extracts the proposal ID by parsing the line starting with \"Proposal ID: \" (strict parsing).  \n * 3. Extracts the proposal URL by parsing the line starting with \"Proposal URL: \" (non-strict parsing).  \n * 4. Returns the populated ProposeUpgradeResponse struct containing both extracted values.  \n */",
                    "tdd": "{'function parseProposeUpgradeResponse(string memory stdout) internal pure returns (ProposeUpgradeResponse memory) {\\n        ProposeUpgradeResponse memory response;\\n        response.proposalId = _parseLine(\"Proposal ID: \", stdout, true);\\n        response.url = _parseLine(\"Proposal URL: \", stdout, false);\\n        return response;\\n    }'}",
                    "context": "set()"
                },
                {
                    "identifier": "buildProposeUpgradeCommand",
                    "parameters": "address proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
                    "modifiers": "view",
                    "return": "returns (string[] memory)",
                    "body": "function buildProposeUpgradeCommand(\n        address proxyAddress,\n        address proxyAdminAddress,\n        address newImplementationAddress,\n        ContractInfo memory contractInfo,\n        Options memory opts\n    ) internal view returns (string[] memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = \"proposeUpgrade\";\n        inputBuilder[i++] = \"--proxyAddress\";\n        inputBuilder[i++] = vm.toString(proxyAddress);\n        inputBuilder[i++] = \"--newImplementationAddress\";\n        inputBuilder[i++] = vm.toString(newImplementationAddress);\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n        inputBuilder[i++] = \"--contractArtifactFile\";\n        inputBuilder[i++] = contractInfo.artifactPath;\n        if (proxyAdminAddress != address(0)) {\n            inputBuilder[i++] = \"--proxyAdminAddress\";\n            inputBuilder[i++] = vm.toString(proxyAdminAddress);\n        }\n        if (!(opts.defender.upgradeApprovalProcessId).toSlice().empty()) {\n            inputBuilder[i++] = \"--approvalProcessId\";\n            inputBuilder[i++] = opts.defender.upgradeApprovalProcessId;\n        }\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
                    "start": "243",
                    "end": "285",
                    "class": "DefenderDeploy",
                    "signature": "returns (string[] memory) buildProposeUpgradeCommandaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
                    "full_signature": "function buildProposeUpgradeCommand(address proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts) internal view returns (string[] memory)",
                    "class_method_signature": "DefenderDeploy.buildProposeUpgradeCommandaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Builds a command for proposing a contract upgrade through OpenZeppelin Defender.\n * \n * @param proxyAddress The address of the proxy contract to upgrade.\n * @param proxyAdminAddress The address of the proxy admin (optional, can be zero address).\n * @param newImplementationAddress The address of the new implementation contract.\n * @param contractInfo Contains the artifact path for the contract.\n * @param opts Additional options including Defender-specific configurations.\n * \n * @return string[] An array of strings forming the complete upgrade proposal command.\n * \n * Steps:\n * 1. Initialize a Vm instance for cheatcode access.\n * 2. Create an input string array with maximum possible length.\n * 3. Populate the command components including:\n *    - Base command (npx)\n *    - Defender CLI package with version\n *    - Command type (proposeUpgrade)\n *    - Proxy and implementation addresses\n *    - Chain ID\n *    - Contract artifact file path\n * 4. Conditionally add proxy admin address if provided.\n * 5. Conditionally add approval process ID if specified in options.\n * 6. Create a properly sized copy of the command array.\n * 7. Return the final command array.\n */",
                    "tdd": "{'function buildProposeUpgradeCommand(\\n        address proxyAddress,\\n        address proxyAdminAddress,\\n        address newImplementationAddress,\\n        ContractInfo memory contractInfo,\\n        Options memory opts\\n    ) internal view returns (string[] memory) {\\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\\n\\n        string[] memory inputBuilder = new string[](255);\\n\\n        uint8 i = 0;\\n\\n        inputBuilder[i++] = \"npx\";\\n        inputBuilder[i++] = string(\\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\\n        );\\n        inputBuilder[i++] = \"proposeUpgrade\";\\n        inputBuilder[i++] = \"--proxyAddress\";\\n        inputBuilder[i++] = vm.toString(proxyAddress);\\n        inputBuilder[i++] = \"--newImplementationAddress\";\\n        inputBuilder[i++] = vm.toString(newImplementationAddress);\\n        inputBuilder[i++] = \"--chainId\";\\n        inputBuilder[i++] = Strings.toString(block.chainid);\\n        inputBuilder[i++] = \"--contractArtifactFile\";\\n        inputBuilder[i++] = contractInfo.artifactPath;\\n        if (proxyAdminAddress != address(0)) {\\n            inputBuilder[i++] = \"--proxyAdminAddress\";\\n            inputBuilder[i++] = vm.toString(proxyAdminAddress);\\n        }\\n        if (!(opts.defender.upgradeApprovalProcessId).toSlice().empty()) {\\n            inputBuilder[i++] = \"--approvalProcessId\";\\n            inputBuilder[i++] = opts.defender.upgradeApprovalProcessId;\\n        }\\n\\n        // Create a copy of inputs but with the correct length\\n        string[] memory inputs = new string[](i);\\n        for (uint8 j = 0; j < i; j++) {\\n            inputs[j] = inputBuilder[j];\\n        }\\n\\n        return inputs;\\n    }'}",
                    "context": "{'VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));', 'function toString(bool value) external pure returns (string memory stringifiedValue);', 'function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }', 'function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }', 'address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;', 'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function chainId(uint256 newChainId) external;', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }', 'function toString(address value) external pure returns (string memory stringifiedValue);', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.7\";', 'function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.9\";', 'function toString(uint256 value) external pure returns (string memory stringifiedValue);', 'function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }', 'function proposeUpgrade(\\n        address proxyAddress,\\n        string memory newImplementationContractName,\\n        Options memory opts\\n    ) internal returns (ProposeUpgradeResponse memory) {\\n        opts.defender.useDefenderDeploy = true;\\n        address proxyAdminAddress = Core.getAdminAddress(proxyAddress);\\n        address newImplementationAddress = Core.prepareUpgrade(newImplementationContractName, opts);\\n        return\\n            DefenderDeploy.proposeUpgrade(\\n                proxyAddress,\\n                proxyAdminAddress,\\n                newImplementationAddress,\\n                newImplementationContractName,\\n                opts\\n            );\\n    }', 'function toString(bytes32 value) external pure returns (string memory stringifiedValue);', 'function toString(bytes calldata value)\\n        external\\n        pure\\n        returns (string memory stringifiedValue);', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\"memory-safe\") {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\"memory-safe\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'function addr(uint256 privateKey) external pure returns (address keyAddr);', 'function toString(int256 value) external pure returns (string memory stringifiedValue);'}"
                },
                {
                    "identifier": "parseApprovalProcessResponse",
                    "parameters": "string memory stdout",
                    "modifiers": "pure",
                    "return": "returns (ApprovalProcessResponse memory)",
                    "body": "function parseApprovalProcessResponse(string memory stdout) internal pure returns (ApprovalProcessResponse memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        ApprovalProcessResponse memory response;\n\n        response.approvalProcessId = _parseLine(\"Approval process ID: \", stdout, true);\n\n        string memory viaString = _parseLine(\"Via: \", stdout, false);\n        if (viaString.toSlice().len() != 0) {\n            response.via = vm.parseAddress(viaString);\n        }\n\n        response.viaType = _parseLine(\"Via type: \", stdout, false);\n\n        return response;\n    }",
                    "start": "300",
                    "end": "315",
                    "class": "DefenderDeploy",
                    "signature": "returns (ApprovalProcessResponse memory) parseApprovalProcessResponsestring memory stdout",
                    "full_signature": "function parseApprovalProcessResponse(string memory stdout) internal pure returns (ApprovalProcessResponse memory)",
                    "class_method_signature": "DefenderDeploy.parseApprovalProcessResponsestring memory stdout",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Parses an approval process response from a given stdout string.\n *\n * Steps:\n * 1. Initialize the Vm instance using the cheatcode address.\n * 2. Create an empty ApprovalProcessResponse struct.\n *\n * 3. Parse the approval process ID from the stdout string.\n * 4. Parse the 'Via' address from the stdout string (if present).\n * 5. Parse the 'Via type' from the stdout string (if present).\n *\n * 6. Return the populated ApprovalProcessResponse struct.\n */",
                    "tdd": "{'function parseApprovalProcessResponse(string memory stdout) internal pure returns (ApprovalProcessResponse memory) {\\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\\n\\n        ApprovalProcessResponse memory response;\\n\\n        response.approvalProcessId = _parseLine(\"Approval process ID: \", stdout, true);\\n\\n        string memory viaString = _parseLine(\"Via: \", stdout, false);\\n        if (viaString.toSlice().len() != 0) {\\n            response.via = vm.parseAddress(viaString);\\n        }\\n\\n        response.viaType = _parseLine(\"Via type: \", stdout, false);\\n\\n        return response;\\n    }'}",
                    "context": "{'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function parseAddress(string memory input) internal pure returns (address) {\\n        return parseAddress(input, 0, bytes(input).length);\\n    }', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }', 'VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(\"hevm cheat code\")))));', 'function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\\n        (bool success, address value) = tryParseAddress(input, begin, end);\\n        if (!success) revert StringsInvalidAddressFormat();\\n        return value;\\n    }', 'function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }', 'function parseAddress(string calldata stringifiedValue)\\n        external\\n        pure\\n        returns (address parsedValue);', 'address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;'}"
                },
                {
                    "identifier": "buildGetApprovalProcessCommand",
                    "parameters": "string memory command",
                    "modifiers": "view",
                    "return": "returns (string[] memory)",
                    "body": "function buildGetApprovalProcessCommand(string memory command) internal view returns (string[] memory) {\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = command;\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
                    "start": "317",
                    "end": "337",
                    "class": "DefenderDeploy",
                    "signature": "returns (string[] memory) buildGetApprovalProcessCommandstring memory command",
                    "full_signature": "function buildGetApprovalProcessCommand(string memory command) internal view returns (string[] memory)",
                    "class_method_signature": "DefenderDeploy.buildGetApprovalProcessCommandstring memory command",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                        "import {Utils, ContractInfo} from \"./Utils.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Options, DefenderOptions} from \"../Options.sol\";",
                        "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
                    ],
                    "llm_comment": " \n/**\n * @notice Builds a command for getting approval process details from OpenZeppelin Defender.  \n *  \n * Steps:  \n * 1. Initializes a string array with a fixed size (255) to store command components.  \n * 2. Constructs the command by adding:  \n *    - The \"npx\" executable  \n *    - The OpenZeppelin Defender CLI package with version  \n *    - The provided command argument  \n *    - The \"--chainId\" flag followed by the current chain ID  \n *  \n * 3. Creates a new string array with the exact length of populated components.  \n * 4. Copies the populated components into the new array.  \n *  \n * @param command The base command to execute (e.g., \"approval:get\").  \n * @return inputs The formatted command components as a string array.  \n */  ",
                    "tdd": "{'function buildGetApprovalProcessCommand(string memory command) internal view returns (string[] memory) {\\n        string[] memory inputBuilder = new string[](255);\\n\\n        uint8 i = 0;\\n\\n        inputBuilder[i++] = \"npx\";\\n        inputBuilder[i++] = string(\\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\\n        );\\n        inputBuilder[i++] = command;\\n        inputBuilder[i++] = \"--chainId\";\\n        inputBuilder[i++] = Strings.toString(block.chainid);\\n\\n        // Create a copy of inputs but with the correct length\\n        string[] memory inputs = new string[](i);\\n        for (uint8 j = 0; j < i; j++) {\\n            inputs[j] = inputBuilder[j];\\n        }\\n\\n        return inputs;\\n    }'}",
                    "context": "{'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function chainId(uint256 newChainId) external;', 'function toString(int256 value) external pure returns (string memory stringifiedValue);', 'function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }', 'function toString(address value) external pure returns (string memory stringifiedValue);', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.7\";', 'function toString(bool value) external pure returns (string memory stringifiedValue);', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }', 'string constant DEFENDER_DEPLOY_CLIENT_CLI = \"0.0.1-alpha.9\";', 'function toString(bytes calldata value)\\n        external\\n        pure\\n        returns (string memory stringifiedValue);', 'function toString(bytes32 value) external pure returns (string memory stringifiedValue);', 'function toString(uint256 value) external pure returns (string memory stringifiedValue);', 'function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }', 'function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            assembly (\"memory-safe\") {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                assembly (\"memory-safe\") {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }'}"
                }
            ]
        }
    ],
    "repository/yui-ibc-solidity/tests/foundry/lib/openzeppelin-foundry-upgrades/src/internal/Core.sol": [
        {
            "methods": [
                {
                    "identifier": "getUpgradeInterfaceVersion",
                    "parameters": "address addr",
                    "modifiers": "view",
                    "return": "returns (string memory)",
                    "body": "function getUpgradeInterfaceVersion(address addr) internal view returns (string memory) {\n        // Use staticcall to prevent forge from broadcasting it\n        (bool success, bytes memory returndata) = addr.staticcall(\n            abi.encodeWithSignature(\"UPGRADE_INTERFACE_VERSION()\")\n        );\n        if (success && returndata.length > 32) {\n            return abi.decode(returndata, (string));\n        } else {\n            return \"\";\n        }\n    }",
                    "start": "309",
                    "end": "319",
                    "class": "Core",
                    "signature": "returns (string memory) getUpgradeInterfaceVersionaddress addr",
                    "full_signature": "function getUpgradeInterfaceVersion(address addr) internal view returns (string memory)",
                    "class_method_signature": "Core.getUpgradeInterfaceVersionaddress addr",
                    "testcase": "",
                    "constructor": "False",
                    "comment": "",
                    "virtual": "",
                    "id": [],
                    "visibility": "internal",
                    "type": "",
                    "type_name": "",
                    "constant": "",
                    "invocations": [],
                    "sol_version": [
                        "pragma solidity ^0.8.0;"
                    ],
                    "import_directive": [
                        "import {Vm} from \"forge-std/Vm.sol\";",
                        "import {console} from \"forge-std/console.sol\";",
                        "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                        "import {Options} from \"../Options.sol\";",
                        "import {Versions} from \"./Versions.sol\";",
                        "import {Utils} from \"./Utils.sol\";",
                        "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                        "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                        "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                        "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
                    ],
                    "llm_comment": "/**\n * @notice Gets the upgrade interface version for a given contract address.\n * @dev Uses staticcall to prevent state changes during the call.\n * \n * Steps:\n * 1. Makes a staticcall to the target address with the UPGRADE_INTERFACE_VERSION signature.\n * 2. If the call succeeds and return data length is greater than 32 bytes:\n *    - Decodes and returns the version string.\n * 3. If the call fails or return data is insufficient:\n *    - Returns an empty string.\n * \n * @param addr The contract address to query for upgrade interface version.\n * @return The upgrade interface version string, or empty string if not available.\n */",
                    "tdd": "{'function getUpgradeInterfaceVersion(address addr) internal view returns (string memory) {\\n        // Use staticcall to prevent forge from broadcasting it\\n        (bool success, bytes memory returndata) = addr.staticcall(\\n            abi.encodeWithSignature(\"UPGRADE_INTERFACE_VERSION()\")\\n        );\\n        if (success && returndata.length > 32) {\\n            return abi.decode(returndata, (string));\\n        } else {\\n            return \"\";\\n        }\\n    }'}",
                    "context": "{'function broadcast(uint256 privateKey) external;', 'function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }', 'function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }', 'uint256 public constant UPGRADE_INTERFACE_VERSION = 5;', 'string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";', 'function UPGRADE_INTERFACE_VERSION() external pure {}', 'function broadcast(address signer) external;', 'function broadcast() external;', 'function addr(uint256 privateKey) external pure returns (address keyAddr);', 'string public constant UPGRADE_INTERFACE_VERSION = \"\";'}"
                }
            ]
        }
    ]
}